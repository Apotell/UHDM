/*
 Do not modify, auto-generated by cloner.py

 Copyright 2019-2020 Alain Dargelas

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 * File:   Reducer.cpp
 * Author: hs
 *
 * Created on November 07, 2024, 00:00 AM
 */

#include <uhdm/Reducer.h>

#include <uhdm/ExprEval.h>
#include <uhdm/uhdm.h>

#include <algorithm>
#include <deque>

namespace StringUtils {
// Tokenize "str" at "multichar_separator"; store in "result" array.
std::vector<std::string_view> &tokenizeMulti(
    std::string_view str, std::string_view multichar_separator,
    std::vector<std::string_view> &result) {
  if (str.empty()) return result;

  size_t start = 0;
  size_t end = 0;
  const size_t sepSize = multichar_separator.size();
  const size_t stringSize = str.size();
  for (size_t i = 0; i < stringSize; i++) {
    bool isSeparator = true;
    for (size_t j = 0; j < sepSize; j++) {
      if (i + j >= stringSize) break;
      if (str[i + j] != multichar_separator[j]) {
        isSeparator = false;
        break;
      }
    }
    if (isSeparator) {
      result.emplace_back(str.data() + start, end - start);
      start = end = end + sepSize;
      i = i + sepSize - 1;
    } else {
      ++end;
    }
  }
  result.emplace_back(str.data() + start, end - start);
  return result;
}

}  // namespace StringUtils

namespace UHDM {

template <typename T>
inline T *Reducer::getNamedObject(const std::deque<T *> &objects,
                                  std::string_view name) {
  std::deque<T *>::const_iterator it = std::find_if(
      objects.cbegin(), objects.cend(),
      [&name](const T *object) { return object->VpiName() == name; });
  return (it == objects.cend()) ? nullptr : *it;
}

template <typename T>
inline T *Reducer::getParentOfType(any *object) {
  any *p = object;
  while (p != nullptr) {
    if (T *const tp = any_cast<T>(p)) {
      return tp;
    }
    p = p->VpiParent();
  }
  return nullptr;
}

void Reducer::reduceArray_expr(array_expr *object) {
  // Create ExprEval object
  // Evaluate input object
  // If succeeded, replace the input object with a constant object
}

void Reducer::reduceOperation(operation *object) {
  scope *inst = getParentOfType<scope>(object);
  bool bIsInvalid = false;
  if (any *const updatedExpr =
          reduceExpr(object, bIsInvalid, nullptr, nullptr, inst,
                     object->VpiLineNo(), object->VpiParent(), false)) {
    if (!bIsInvalid) m_swaps.emplace(object, updatedExpr);
  }
}

std::pair<task_func *, scope *> Reducer::getTaskFunc(std::string_view name,
                                                     scope *component,
                                                     any *compileDesign,
                                                     scope *instance,
                                                     any *pexpr) {
  std::pair<task_func *, scope *> result = {nullptr, nullptr};
  scope *comp = component;
  // if (name.find("::") != std::string::npos) {
  //   std::vector<std::string_view> res;
  //   StringUtils::tokenizeMulti(name, "::", res);
  //   if (res.size() > 1) {
  //     const std::string_view packName = res[0];
  //     const std::string_view funcName = res[1];
  //     Design *design = compileDesign->getCompiler()->getDesign();
  //     if (Package *pack = design->getPackage(packName)) {
  //       if (pack->getTask_funcs()) {
  //         for (task_func *tf : *pack->getTask_funcs()) {
  //           if (tf->VpiName() == funcName) {
  //             result = std::make_pair(tf, pack);
  //             return result;
  //           }
  //         }
  //       }
  //     }
  //   }
  // }
  // while (comp) {
  //   if (comp->getTask_funcs()) {
  //     for (task_func *tf : *comp->getTask_funcs()) {
  //       if (tf->VpiName() == name) {
  //         result = std::make_pair(tf, component);
  //         return result;
  //       }
  //     }
  //   }
  //   comp = valuedcomponenti_cast<DesignComponent *>(
  //       (DesignComponent *)comp->getParentScope());
  // }
  // if (component) {
  //   for (const FileContent *cfC : component->getFileContents()) {
  //     FileContent *fC = (FileContent *)cfC;
  //     if (fC->getTask_funcs()) {
  //       for (task_func *tf : *fC->getTask_funcs()) {
  //         if (tf->VpiName() == name) {
  //           result = std::make_pair(tf, component);
  //           return result;
  //         }
  //       }
  //     }
  //   }
  // }
  // if (component) {
  //   std::set<DesignComponent *> visited;
  //   task_func *res = getFuncFromPackage(name, component, visited);
  //   if (res) {
  //     result = std::make_pair(res, component);
  //     return result;
  //   }
  // }
  // if (instance) {
  //   ModuleInstance *inst = valuedcomponenti_cast<ModuleInstance *>(instance);
  //   while (inst) {
  //     DesignComponent *def = inst->getDefinition();
  //     if (def) {
  //       if (def->getTask_funcs()) {
  //         for (task_func *tf : *def->getTask_funcs()) {
  //           if (tf->VpiName() == name) {
  //             result = std::make_pair(tf, def);
  //             return result;
  //           }
  //         }
  //       }
  //     }
  //     inst = inst->getParent();
  //   }
  // }
  // Design *design = compileDesign->getCompiler()->getDesign();
  // auto &all_files = design->getAllFileContents();
  // for (const auto &file : all_files) {
  //   FileContent *fC = file.second;
  //   if (fC->getTask_funcs()) {
  //     for (task_func *tf : *fC->getTask_funcs()) {
  //       if (tf->VpiName() == name) {
  //         result = std::make_pair(tf, component);
  //         return result;
  //       }
  //     }
  //   }
  // }
  return result;
}

any *Reducer::getObject(std::string_view name, scope *component,
                        any *compileDesign, scope *instance, const any *pexpr) {
  any *result = nullptr;
  // while (pexpr) {
  //   if (const scope *s = any_cast<const scope *>(pexpr)) {
  //     if ((result == nullptr) && s->Variables()) {
  //       for (auto o : *s->Variables()) {
  //         if (o->VpiName() == name) {
  //           result = o;
  //           break;
  //         }
  //       }
  //     }
  //   }
  //   if (const task_func *s = any_cast<const task_func *>(pexpr)) {
  //     if ((result == nullptr) && s->Io_decls()) {
  //       for (auto o : *s->Io_decls()) {
  //         if (o->VpiName() == name) {
  //           result = o;
  //           break;
  //         }
  //       }
  //     }
  //   }
  //   if (result) break;
  //   pexpr = pexpr->VpiParent();
  // }
  // if ((result == nullptr) && instance) {
  //   if (ModuleInstance *inst =
  //           valuedcomponenti_cast<ModuleInstance *>(instance)) {
  //     while (inst) {
  //       Netlist *netlist = inst->getNetlist();
  //       if (netlist) {
  //         if ((result == nullptr) && netlist->array_nets()) {
  //           for (auto o : *netlist->array_nets()) {
  //             if (o->VpiName() == name) {
  //               result = o;
  //               break;
  //             }
  //           }
  //         }
  //         if ((result == nullptr) && netlist->nets()) {
  //           for (auto o : *netlist->nets()) {
  //             if (o->VpiName() == name) {
  //               result = o;
  //               break;
  //             }
  //           }
  //         }
  //         if ((result == nullptr) && netlist->variables()) {
  //           for (auto o : *netlist->variables()) {
  //             if (o->VpiName() == name) {
  //               result = o;
  //               break;
  //             }
  //           }
  //         }
  //         if ((result == nullptr) && netlist->ports()) {
  //           for (auto o : *netlist->ports()) {
  //             if (o->VpiName() == name) {
  //               result = o;
  //               break;
  //             }
  //           }
  //         }
  //         if ((result == nullptr) && netlist->param_assigns()) {
  //           for (auto o : *netlist->param_assigns()) {
  //             const std::string_view pname = o->Lhs()->VpiName();
  //             if (pname == name) {
  //               result = o;
  //               break;
  //             }
  //           }
  //         }
  //       }
  //       if ((result == nullptr) ||
  //           (result && (result->UhdmType() != uhdmconstant) &&
  //            (result->UhdmType() != uhdmparam_assign))) {
  //         if (expr *complex = instance->getComplexValue(name)) {
  //           result = complex;
  //         }
  //       }
  //       if (result) break;
  //       if (inst) {
  //         VObjectType insttype = inst->getType();
  //         if ((insttype != VObjectType::paInterface_instantiation) &&
  //             (insttype != VObjectType::paConditional_generate_construct) &&
  //             (insttype != VObjectType::paLoop_generate_construct) &&
  //             (insttype != VObjectType::paGenerate_item) &&
  //             (insttype !=
  //              VObjectType::paGenerate_module_conditional_statement) &&
  //             (insttype !=
  //              VObjectType::paGenerate_interface_conditional_statement) &&
  //             (insttype != VObjectType::paGenerate_module_loop_statement) &&
  //             (insttype != VObjectType::paGenerate_interface_loop_statement)
  //             && (insttype != VObjectType::paGenerate_module_named_block) &&
  //             (insttype != VObjectType::paGenerate_interface_named_block) &&
  //             (insttype != VObjectType::paGenerate_module_block) &&
  //             (insttype != VObjectType::paGenerate_interface_block) &&
  //             (insttype != VObjectType::paGenerate_module_item) &&
  //             (insttype != VObjectType::paGenerate_interface_item) &&
  //             (insttype != VObjectType::paGenerate_begin_end_block)) {
  //           break;
  //         } else {
  //           inst = inst->getParent();
  //         }
  //       }
  //     }
  //   }
  // }
  //// Instance component or package component
  // if ((result == nullptr) && component) {
  //   for (ParamAssign *pass : component->getParamAssignVec()) {
  //     if (param_assign *p = pass->getUhdmParamAssign()) {
  //       const std::string_view pname = p->Lhs()->VpiName();
  //       if (pname == name) {
  //         if (substituteAssignedValue(p->Rhs(), compileDesign)) {
  //           result = (any *)p->Rhs();
  //           break;
  //         }
  //       }
  //     }
  //   }
  //   const DataType *dtype = component->getDataType(name);
  //   if ((result == nullptr) && dtype) {
  //     dtype = dtype->getActual();
  //     if (dtype->getTypespec()) result = dtype->getTypespec();
  //   }

  //  Signal *sig = nullptr;
  //  for (auto s : component->getPorts()) {
  //    if (s->getName() == name) {
  //      sig = s;
  //      break;
  //    }
  //  }
  //  if (sig == nullptr) {
  //    for (auto s : component->getSignals()) {
  //      if (s->getName() == name) {
  //        sig = s;
  //        break;
  //      }
  //    }
  //  }
  //  if (sig) {
  //    if (sig->getTypeSpecId()) {
  //      result = compileTypespec(component, sig->getFileContent(),
  //                               sig->getTypeSpecId(), compileDesign,
  //                               Reduce::No, nullptr, instance, true);
  //    }
  //  }
  //}

  // if ((result == nullptr) && instance) {
  //   if (ModuleInstance *inst =
  //           valuedcomponenti_cast<ModuleInstance *>(instance)) {
  //     // Instance component
  //     if (DesignComponent *comp = inst->getDefinition()) {
  //       for (ParamAssign *pass : comp->getParamAssignVec()) {
  //         if (param_assign *p = pass->getUhdmParamAssign()) {
  //           const std::string_view pname = p->Lhs()->VpiName();
  //           if (pname == name) {
  //             if (substituteAssignedValue(p->Rhs(), compileDesign)) {
  //               result = (any *)p->Rhs();
  //               break;
  //             }
  //           }
  //         }
  //       }

  //      const DataType *dtype = comp->getDataType(name);
  //      if ((result == nullptr) && dtype) {
  //        dtype = dtype->getActual();
  //        if (dtype->getTypespec()) result = dtype->getTypespec();
  //      }
  //    }
  //  }
  //}

  // if (result && (result->UhdmType() == uhdmref_obj)) {
  //   ref_obj *ref = (ref_obj *)result;
  //   const std::string_view refname = ref->VpiName();
  //   if (refname != name)
  //     result = getObject(refname, component, compileDesign, instance, pexpr);
  //   if (result) {
  //     if (param_assign *passign = any_cast<param_assign *>(result)) {
  //       result = (any *)passign->Rhs();
  //     }
  //   }
  // }
  // if (result && result->UhdmType() == uhdmconstant) {
  //   if (instance) {
  //     Value *sval = instance->getValue(name);
  //     if (sval && sval->isValid()) {
  //       setRange((constant *)result, sval, compileDesign);
  //     }
  //   }
  // }
  return result;
}

expr *Reducer::reduceExpr(any *result, bool &invalidValue, scope *component,
                          any *compileDesign, scope *instance,
                          uint32_t lineNumber, any *pexpr, bool muteErrors) {
  GetObjectFunctor getObjectFunctor =
      [&](std::string_view name, const any *inst, const any *pexpr) -> any * {
    return getObject(name, component, compileDesign, instance, pexpr);
  };
  GetObjectFunctor getValueFunctor = [&](std::string_view name, const any *inst,
                                         const any *pexpr) -> any * {
    return (expr *)getValue(name, component, compileDesign, instance,
                            lineNumber, (any *)pexpr, muteErrors);
  };
  GetTaskFuncFunctor getTaskFuncFunctor = [&](std::string_view name,
                                              const any *inst) -> task_func * {
    auto ret = getTaskFunc(name, component, compileDesign, instance, pexpr);
    return ret.first;
  };

  ExprEval eval(muteErrors);
  eval.setGetObjectFunctor(getObjectFunctor);
  eval.setGetValueFunctor(getValueFunctor);
  eval.setGetTaskFuncFunctor(getTaskFuncFunctor);
  if (m_exprEvalPlaceHolder == nullptr) {
    m_exprEvalPlaceHolder = m_serializer->MakeModule_inst();
    m_exprEvalPlaceHolder->Param_assigns(m_serializer->MakeParam_assignVec());
  } else {
    m_exprEvalPlaceHolder->Param_assigns()->erase(
        m_exprEvalPlaceHolder->Param_assigns()->begin(),
        m_exprEvalPlaceHolder->Param_assigns()->end());
  }
  expr *res = eval.reduceExpr(result, invalidValue, m_exprEvalPlaceHolder,
                              pexpr, muteErrors);
  // If loop was detected, drop the partially constructed new value!
  return m_unwind ? nullptr : res;
}

void Reducer::setRange(constant *c, uint16_t lr, uint16_t rr) {
  if (!c) return;

  // uint16_t lr = val->getLRange();
  // uint16_t rr = val->getRRange();
  if (lr || rr) {
    logic_typespec *tps = m_serializer->MakeLogic_typespec();
    ref_typespec *tpsRef = m_serializer->MakeRef_typespec();
    tpsRef->VpiParent(c);
    tpsRef->Actual_typespec(tps);
    c->Typespec(tpsRef);
    range *r = m_serializer->MakeRange();
    r->VpiParent(tps);
    VectorOfrange *ranges = m_serializer->MakeRangeVec();
    ranges->push_back(r);
    tps->Ranges(ranges);
    constant *lc = m_serializer->MakeConstant();
    lc->VpiValue("UINT:" + std::to_string(lr));
    r->Left_expr(lc);
    constant *rc = m_serializer->MakeConstant();
    rc->VpiValue("UINT:" + std::to_string(rr));
    r->Right_expr(rc);
  }
}

bool Reducer::loopDetected(uint32_t lineNumber, any *compileDesign,
                           scope *instance) {
  // @todo: Need to implement loop detection in different way. Currently
  // returning false.
  return false;
}

design *Reducer::getDesign(std::string_view name) {
  const std::deque<design *> &designs = m_serializer->getDesignObjects();
  if (name.empty() && (designs.size() == 1)) {
    return designs.back();
  }
  return getNamedObject(designs, name);
}

package *Reducer::getPackage(std::string_view name) {
  return getNamedObject(m_serializer->getPackageObjects(), name);
}

// getComplexValue(
// map<scope*, name, expr*>
// iterate thriough scope and it know all the trees and get aal the expression
// then if it is complex then fill the ,map and utilize the lookup form built
// map

expr *Reducer::getComplexValue(scope *object, std::string_view name) const {
  any *p = object;
  while (p != nullptr) {
    if (scope *const s = any_cast<scope>(p)) {
      if (VectorOfparam_assign *param_assigns = s->Param_assigns()) {
        for (param_assign *param : *param_assigns) {
          if (param && param->Lhs()) {
            if (param->Lhs()->VpiName() == name) {
              if (expr *exp = param->Rhs<expr>()) {
                return exp;
              }
            }
          }
        }
      }
    }
    p = p->VpiParent();
  }
  return nullptr;
}

// on the fly just get the expr using name
any *Reducer::getValue(std::string_view name, scope *component,
                       any *compileDesign, scope *instance, uint32_t lineNumber,
                       any *pexpr, bool muteErrors) {
  // Value *sval = nullptr;
  any *result = nullptr;
  if (loopDetected(lineNumber, compileDesign, instance)) {
    return nullptr;
  }
  if (m_checkForLoops) {
    m_stackLevel++;
  }
  if (name.find("::") != std::string::npos) {
    std::vector<std::string_view> res;
    StringUtils::tokenizeMulti(name, "::", res);
    if (res.size() > 1) {
      const std::string_view packName = res[0];
      const std::string_view varName = res[1];
      if (package *pack = getPackage(packName)) {
        if (expr *val = getComplexValue(pack, varName)) {
          result = val;
          if (result->UhdmType() == uhdmoperation) {
            operation *op = (operation *)result;
            const typespec *opts = nullptr;
            if (ref_typespec *rt = op->Typespec()) {
              opts = rt->Actual_typespec();
            }
            /*
            ExprEval eval;
            if (expr *res = eval.flattenPatternAssignments(
                    s, opts, (expr *)result)) {
              if (res->UhdmType() == uhdmoperation) {
                op->Operands(((operation *)res)->Operands());
              }
            }
            */
          }
        }
        if (result == nullptr) {
          // Need to get input about Value
          // if (Value *sval = pack->getValue(varName)) {
          //  constant *c = s.MakeConstant();
          //  c->VpiValue(sval->uhdmValue());
          //  setRange(c, sval, compileDesign);
          //  c->VpiDecompile(sval->decompiledValue());
          //  c->VpiConstType(sval->vpiValType());
          //  c->VpiSize(sval->getSize());
          //  result = c;
          //}
        }
      }
    }
  }

  if ((result == nullptr) && instance) {
    if (expr *val = getComplexValue(instance, name)) {
      result = val;
      if (result->UhdmType() == uhdmconstant) {
        // sval = instance->getValue(name);
        // if (sval && sval->isValid()) {
        //   setRange((constant *)result, sval);
        // }
      }
    }
    if (result == nullptr) {
      // sval = instance->getValue(name);
      // if (sval && sval->isValid()) {
      //   constant *c = s.MakeConstant();
      //   c->VpiValue(sval->uhdmValue());
      //   setRange(c, sval, compileDesign);
      //   c->VpiDecompile(sval->decompiledValue());
      //   c->VpiConstType(sval->vpiValType());
      //   c->VpiSize(sval->getSize());
      //   result = c;
      // }
    }
  }
  /*
  ValuedComponentI *tmpInstance = instance;
  while ((result == nullptr) && tmpInstance) {
    if (ModuleInstance *inst =
            valuedcomponenti_cast<ModuleInstance *>(tmpInstance)) {
      Netlist *netlist = inst->getNetlist();
      if (netlist) {
        VectorOfparam_assign *param_assigns = netlist->param_assigns();
        if (param_assigns) {
          for (param_assign *param : *param_assigns) {
            if (param && param->Lhs()) {
              const std::string_view param_name = param->Lhs()->VpiName();
              if (param_name == name) {
                if (substituteAssignedValue(param->Rhs(), compileDesign)) {
                  if (param->Rhs()->UhdmType() == uhdmoperation) {
                    operation *op = (operation *)param->Rhs();
                    int32_t opType = op->VpiOpType();
                    if (opType == vpiAssignmentPatternOp) {
                      const any *lhs = param->Lhs();
                      any *rhs = param->Rhs();
                      const typespec *ts = nullptr;
                      if (lhs->UhdmType() == uhdmparameter) {
                        if (const ref_typespec *rt =
                                ((parameter *)lhs)->Typespec()) {
                          ts = rt->Actual_typespec();
                        }
                      }
                      rhs = expandPatternAssignment(ts, (expr *)rhs, component,
                                                    compileDesign, instance);
                      param->Rhs(rhs);
                      reorderAssignmentPattern(component, lhs, rhs,
                                               compileDesign, instance, 0);
                    }
                  }

                  ElaboratorContext elaboratorContext(&s, false, true);
                  result =
                      clone_tree((any *)param->Rhs(), &elaboratorContext);
                  break;
                }
              }
            }
          }
        }
        if (auto variables = netlist->variables()) {
          for (auto var : *variables) {
            if (var->VpiName() == name) {
              if (const expr *exp = var->Expr()) {
                UHDM_OBJECT_TYPE vartype = var->UhdmType();
                if (vartype == uhdmint_var || vartype == uhdminteger_var ||
                    vartype == uhdmreal_var || vartype == uhdmshort_int_var ||
                    vartype == uhdmlong_int_var)
                  result = (expr *)exp;
                break;
              }
            }
          }
        }
      }
    }
    if (result) break;
    if (ModuleInstance *inst =
            valuedcomponenti_cast<ModuleInstance *>(tmpInstance)) {
      tmpInstance = (ValuedComponentI *)inst->getParentScope();
    } else if (FScope *inst = valuedcomponenti_cast<FScope *>(tmpInstance)) {
      tmpInstance = (ValuedComponentI *)inst->getParentScope();
    } else {
      tmpInstance = nullptr;
    }
  }

  if (result == nullptr) {
    if (instance) {
      if (expr *val = instance->getComplexValue(name)) {
        result = val;
      }
      if (result == nullptr) {
        sval = instance->getValue(name);
        if (sval && sval->isValid()) {
          constant *c = s.MakeConstant();
          c->VpiValue(sval->uhdmValue());
          setRange(c, sval, compileDesign);
          c->VpiDecompile(sval->decompiledValue());
          c->VpiConstType(sval->vpiValType());
          c->VpiSize(sval->getSize());
          result = c;
        }
      }
    }
  }

  if (component && (result == nullptr)) {
    if (expr *val = component->getComplexValue(name)) {
      result = val;
    }
    if (result == nullptr) {
      sval = component->getValue(name);
      if (sval && sval->isValid()) {
        constant *c = s.MakeConstant();
        c->VpiValue(sval->uhdmValue());
        setRange(c, sval, compileDesign);
        c->VpiDecompile(sval->decompiledValue());
        c->VpiConstType(sval->vpiValType());
        c->VpiSize(sval->getSize());
        result = c;
      }
    }
  }

  if (component && (result == nullptr)) {
    if (VectorOfparam_assign *param_assigns =
            component->getParam_assigns()) {
      for (param_assign *param : *param_assigns) {
        if (param && param->Lhs()) {
          const std::string_view param_name = param->Lhs()->VpiName();
          if (param_name == name) {
            if (substituteAssignedValue(param->Rhs(), compileDesign)) {
              if (param->Rhs()->UhdmType() == uhdmoperation) {
                operation *op = (operation *)param->Rhs();
                int32_t opType = op->VpiOpType();
                if (opType == vpiAssignmentPatternOp) {
                  const any *lhs = param->Lhs();
                  any *rhs = param->Rhs();
                  const typespec *ts = nullptr;
                  if (lhs->UhdmType() == uhdmparameter) {
                    if (const ref_typespec *rt =
                            ((parameter *)lhs)->Typespec()) {
                      ts = rt->Actual_typespec();
                    }
                  }
                  rhs = expandPatternAssignment(ts, (expr *)rhs, component,
                                                compileDesign, instance);
                  param->Rhs(rhs);
                  reorderAssignmentPattern(component, lhs, rhs, compileDesign,
                                           instance, 0);
                }
              }

              ElaboratorContext elaboratorContext(&s, false, true);
              result =
                  clone_tree((any *)param->Rhs(), &elaboratorContext);
              if (result != nullptr) result->VpiParent(param);
              break;
            }
          }
        }
      }
    }
  }
  if (component && (result == nullptr)) {
    for (const auto &tp : component->getTypeDefMap()) {
      TypeDef *tpd = tp.second;
      typespec *tps = tpd->getTypespec();
      if (tps && tps->UhdmType() == uhdmenum_typespec) {
        enum_typespec *etps = (enum_typespec *)tps;
        for (auto n : *etps->Enum_consts()) {
          if (n->VpiName() == name) {
            constant *c = s.MakeConstant();
            c->VpiValue(n->VpiValue());
            setRange(c, sval, compileDesign);
            c->VpiSize(64);
            c->VpiConstType(vpiUIntConst);
            result = c;
          }
        }
      }
    }
  }
  */
  if (result) {
    UHDM_OBJECT_TYPE resultType = result->UhdmType();
    if (resultType == uhdmconstant) {
    } else if (resultType == uhdmref_obj) {
      if (result->VpiName() != name) {
        if (any *tmp = getValue(result->VpiName(), component, compileDesign,
                                instance, lineNumber, pexpr, muteErrors)) {
          result = tmp;
        }
      }
    } else if (resultType == uhdmoperation || resultType == uhdmhier_path ||
               resultType == uhdmbit_select ||
               resultType == uhdmsys_func_call) {
      bool invalidValue = false;
      if (any *tmp = reduceExpr(result, invalidValue, component, compileDesign,
                                instance, lineNumber, pexpr, muteErrors)) {
        result = tmp;
      }
    } else {
      int32_t setBreakpointHere = 1;
      setBreakpointHere++;
    }
  }
  if (m_checkForLoops) {
    m_stackLevel--;
  }
  return result;
}

void Reducer::reduce() {
  for (operation *object : m_serializer->getOperationObjects()) {
    reduceOperation(object);
  }

  for (design *object : m_serializer->getDesignObjects()) {
    object->Swap(m_swaps);
  }
}

}  // namespace UHDM
