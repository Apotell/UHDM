/*
 Do not modify, auto-generated by script

 Copyright 2019 Alain Dargelas

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 * File:   models_impl.cpp
 * Author: hs-apotell
 *
 * Created on May 13, 2024, 00:00 AM
 */

#include <uhdm/uhdm.h>

#include <algorithm>

#define ADD_TO_COLLECTION(class_type, property_name)          \
  if (class_type* const childT = child->Cast<class_type>()) { \
    property_name(true)->emplace_back(childT);                \
  }

#define REMOVE_FROM_COLLECTION(class_type, property_name)              \
  if (class_type* const childT = child->Cast<class_type>()) {          \
    if (auto collection = property_name(false)) {                      \
      collection->erase(                                               \
          std::remove(collection->begin(), collection->end(), childT), \
          collection->end());                                          \
    }                                                                  \
  }

namespace UHDM {
void scope::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
  ADD_TO_COLLECTION(property_decl, Property_decls);
  ADD_TO_COLLECTION(sequence_decl, Sequence_decls);
  ADD_TO_COLLECTION(concurrent_assertions, Concurrent_assertions);
  ADD_TO_COLLECTION(named_event, Named_events);
  ADD_TO_COLLECTION(named_event_array, Named_event_arrays);
  ADD_TO_COLLECTION(variables, Variables);
  ADD_TO_COLLECTION(virtual_interface_var, Virtual_interface_vars);
  ADD_TO_COLLECTION(logic_var, Logic_vars);
  ADD_TO_COLLECTION(array_var, Array_vars);
  // ADD_TO_COLLECTION(array_var_mems, Array_var_mems);
  ADD_TO_COLLECTION(parameter, Parameters);
  ADD_TO_COLLECTION(param_assign, Param_assigns);
  ADD_TO_COLLECTION(scope, Scopes);
  ADD_TO_COLLECTION(typespec, Typespecs);
  // ADD_TO_COLLECTION(instance_item, Instance_items);
  ADD_TO_COLLECTION(let_decl, Let_decls);
  ADD_TO_COLLECTION(attribute, Attributes);
}

void scope::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
  REMOVE_FROM_COLLECTION(property_decl, Property_decls);
  REMOVE_FROM_COLLECTION(sequence_decl, Sequence_decls);
  REMOVE_FROM_COLLECTION(concurrent_assertions, Concurrent_assertions);
  REMOVE_FROM_COLLECTION(named_event, Named_events);
  REMOVE_FROM_COLLECTION(named_event_array, Named_event_arrays);
  REMOVE_FROM_COLLECTION(variables, Variables);
  REMOVE_FROM_COLLECTION(virtual_interface_var, Virtual_interface_vars);
  REMOVE_FROM_COLLECTION(logic_var, Logic_vars);
  REMOVE_FROM_COLLECTION(array_var, Array_vars);
  // REMOVE_FROM_COLLECTION(array_var_mems, Array_var_mems);
  REMOVE_FROM_COLLECTION(parameter, Parameters);
  REMOVE_FROM_COLLECTION(param_assign, Param_assigns);
  REMOVE_FROM_COLLECTION(scope, Scopes);
  REMOVE_FROM_COLLECTION(typespec, Typespecs);
  // REMOVE_FROM_COLLECTION(instance_item, Instance_items);
  REMOVE_FROM_COLLECTION(let_decl, Let_decls);
  REMOVE_FROM_COLLECTION(attribute, Attributes);
}

void begin::OnChildAdded(BaseClass* child) { basetype_t::OnChildAdded(child); }
void begin::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void fork_stmt::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void fork_stmt::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void for_stmt::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void for_stmt::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void foreach_stmt::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void foreach_stmt::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void gen_scope::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void gen_scope::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void task_func::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void task_func::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void task::OnChildAdded(BaseClass* child) { basetype_t::OnChildAdded(child); }
void task::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void function::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void function::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void clocking_block::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void clocking_block::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void class_defn::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void class_defn::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void class_obj::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void class_obj::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void instance::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void instance::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void interface_inst::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void interface_inst::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void program::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void program::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void package::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void package::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void module_inst::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void module_inst::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void checker_decl::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void checker_decl::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void checker_inst::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void checker_inst::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void gen_for::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void gen_for::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void gen_region::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
}
void gen_region::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
}

void udp_defn::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
  ADD_TO_COLLECTION(io_decl, Io_decls);
  ADD_TO_COLLECTION(table_entry, Table_entrys);
}
void udp_defn::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
  REMOVE_FROM_COLLECTION(io_decl, Io_decls);
  REMOVE_FROM_COLLECTION(table_entry, Table_entrys);
}

void design::OnChildAdded(BaseClass* child) {
  basetype_t::OnChildAdded(child);
  ADD_TO_COLLECTION(typespec, Typespecs);
  ADD_TO_COLLECTION(let_decl, Let_decls);
  ADD_TO_COLLECTION(task_func, Task_funcs);
  ADD_TO_COLLECTION(parameter, Parameters);
  ADD_TO_COLLECTION(param_assign, Param_assigns);
}
void design::OnChildRemoved(BaseClass* child) {
  basetype_t::OnChildRemoved(child);
  REMOVE_FROM_COLLECTION(typespec, Typespecs);
  REMOVE_FROM_COLLECTION(let_decl, Let_decls);
  REMOVE_FROM_COLLECTION(task_func, Task_funcs);
  REMOVE_FROM_COLLECTION(parameter, Parameters);
  REMOVE_FROM_COLLECTION(param_assign, Param_assigns);
}

}  // namespace UHDM
