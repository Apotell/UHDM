/*
 Do not modify, auto-generated by script

 Copyright 2019 Alain Dargelas

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 * File:   Serializer.cpp
 * Author:
 *
 * Created on October 4, 2021, 10:53 PM
 */
#include <uhdm/Serializer.h>
#include <uhdm/UhdmListener.h>
#include <uhdm/uhdm.h>
#include <uhdm/vpi_visitor.h>

#include <algorithm>
#include <iomanip>
#include <iostream>
#include <map>
#include <string>
#include <vector>

namespace uhdm {

const uint32_t Serializer::kVersion = 1;

Serializer::Serializer() {
<INIT_FACTORIES>
}

Serializer::~Serializer() { purge(); }

void Serializer::collectGarbage() {
  if (!m_enableGC) return;

  Factory* const factory = m_factories[UhdmType::Design];
  UhdmListener* const listener = new UhdmListener();

  // PreprocMacroInstance has collection of objects that aren't parent to
  // instance itself. The parent of any of these objects could be deleted
  // leaving the object still in its collection. These obejcts are
  // weak-references and shouldn't be accounted for towards visitation.
  // Fortunately, this is the only collection in PreprocMacroInstance and
  // so we can cleanly/safely avoid visiting the instance itself.
  Factory* const preprocMacroInstanceFactory =
      m_factories[PreprocMacroInstance::kUhdmType];
  listener->getVisited().insert(preprocMacroInstanceFactory->m_objects.cbegin(),
                                preprocMacroInstanceFactory->m_objects.cend());
  for (auto d : factory->m_objects) {
    listener->listenDesign(any_cast<Design>(d));
  }

  const AnySet visited(listener->getVisited().begin(),
                       listener->getVisited().end());
  delete listener;

  AnySet erased;
  for (factories_t::const_reference entry : m_factories) {
    entry.second->eraseIfNotIn(visited, erased);
  }

  // Remove objects from PreprocMacroInstance that have been erased.
  for (Any* pmi : preprocMacroInstanceFactory->m_objects) {
    if (AnyCollection* const objects = any_cast<PreprocMacroInstance>(pmi)
            ->getObjects()) {
      AnyCollection keepers;
      std::copy_if(objects->cbegin(), objects->cend(),
                   std::back_inserter(keepers),
                   [&erased](const Any* const any) {
                     return erased.find(any) == erased.cend();
                   });
      objects->swap(keepers);
    }
  }
}

void DefaultErrorHandler(ErrorType errType, const std::string& errorMsg,
                         const Any* object1, const Any* object2) {
  std::cerr << errorMsg << std::endl;
}

SymbolId Serializer::makeSymbol(std::string_view symbol) {
  return m_symbolFactory.registerSymbol(symbol);
}

std::string_view Serializer::getSymbol(SymbolId id) const {
  return m_symbolFactory.getSymbol(id);
}

SymbolId Serializer::getSymbolId(std::string_view symbol) const {
  return m_symbolFactory.getId(symbol);
}

vpiHandle Serializer::makeUhdmHandle(UhdmType type,
                                     const void* object) {
  return m_uhdmHandleFactory.make(type, object);
}

SymbolCollection* Serializer::makeSymbolCollection() {
  // return m_symbolVectorFactory.make();
  return nullptr;
}

Serializer::IdMap Serializer::getAllObjects() const {
  IdMap idMap;
  for (factories_t::const_reference entry : m_factories) {
    entry.second->mapToIndex(idMap);
  }
  return idMap;
}

std::string UhdmName(UhdmType type) {
  switch (type) {
<UHDM_NAME_MAP>
    default: return "NO TYPE";
  }
}

// From uhdm_types.h
std::string VpiTypeName(vpiHandle h) {
  uhdm_handle* handle = (uhdm_handle*)h;
  BaseClass* obj = (BaseClass*)handle->object;
  return UhdmName(obj->getUhdmType());
}

std::map<std::string, uint32_t, std::less<>> Serializer::getObjectStats() const {
  std::map<std::string, uint32_t, std::less<>> stats;
  for (factories_t::const_reference entry : m_factories) {
    stats.emplace(UhdmName(entry.first), entry.second->m_objects.size());
  }
  return stats;
}

void Serializer::printStats(std::ostream& strm,
                            std::string_view infoText) const {
  strm << "=== UHDM Object Stats Begin (" << infoText << ") ===" << std::endl;
  auto stats = getObjectStats();
  std::vector<std::string_view> names;
  names.reserve(stats.size());
  std::transform(stats.begin(), stats.end(), std::back_inserter(names),
                 [](decltype(stats)::value_type const& pair) {
                   return std::string_view(pair.first);
                 });
  std::sort(names.begin(), names.end());
  for (std::string_view name : names) {
    auto it = stats.find(name);
    if (it->second > 0) {
      // The longest model name is
      // "enum_struct_union_packed_array_typespec_group"
      strm << std::setw(48) << std::left << name << std::setw(8) << std::right
           << it->second << std::endl;
    }
  }
  strm << "=== UHDM Object Stats End ===" << std::endl;
}

bool Serializer::erase(const BaseClass* p) {
  if (p == nullptr) {
    return true;
  }

  return m_factories[p->getUhdmType()]->erase(p);
}

void Serializer::purge() {
  m_symbolFactory.purge();
  m_uhdmHandleFactory.purge();
  for (factories_t::const_reference entry : m_factories) {
    entry.second->purge();
  }
}

#ifndef SWIG
void Serializer::pushScope(Any* s) {
  if ((any_cast<Scope>(s) != nullptr) || (any_cast<Design>(s) != nullptr)) {
    m_scopeStack.emplace_back(s);
  }
}

bool Serializer::popScope(Any* s) {
  if (!m_scopeStack.empty() && (m_scopeStack.back() == s)) {
    m_scopeStack.pop_back();
    return true;
  }
  return false;
}

ScopedScope::ScopedScope(Any* s) : m_any(s) {
  m_any->getSerializer()->pushScope(s);
}

ScopedScope::~ScopedScope() { m_any->getSerializer()->popScope(m_any); }
#endif
}  // namespace uhdm
