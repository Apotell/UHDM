/*
 Do not modify, auto-generated by script

 Copyright 2019-2020 Alain Dargelas

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 * File:   clone_tree.cpp
 * Author:
 *
 * Created on December 14, 2019, 10:03 PM
 */
#include <uhdm/ElaboratorListener.h>
#include <uhdm/ExprEval.h>
#include <uhdm/clone_tree.h>
#include <uhdm/uhdm.h>

namespace uhdm {

BaseClass* clone_tree(const BaseClass* root, CloneContext* context) {
  return root ? root->deepClone(nullptr, context) : nullptr;
}

TFCall* SysFuncCall::deepClone(BaseClass* parent, CloneContext* context) const {
  SysFuncCall* const clone = context->m_serializer->make<SysFuncCall>();
  const uint32_t id = clone->getUhdmId();
  *clone = *this;
  clone->setUhdmId(id);
  clone->setParent(parent);
  if (auto obj = getUserSystf())
    clone->setUserSystf(obj->deepClone(clone, context));
  if (auto obj = getScope()) clone->setScope(obj->deepClone(clone, context));
  if (auto vec = getArguments()) {
    clone->setArguments(nullptr);
    auto clone_vec = clone->getArguments(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto obj = getTypespec())
    clone->setTypespec(obj->deepClone(clone, context));

  return clone;
}

TFCall* SysTaskCall::deepClone(BaseClass* parent, CloneContext* context) const {
  SysTaskCall* const clone = context->m_serializer->make<SysTaskCall>();
  const uint32_t id = clone->getUhdmId();
  *clone = *this;
  clone->setUhdmId(id);
  clone->setParent(parent);
  if (auto obj = getUserSystf())
    clone->setUserSystf(obj->deepClone(clone, context));
  if (auto obj = getScope()) clone->setScope(obj->deepClone(clone, context));
  if (auto vec = getArguments()) {
    clone->setArguments(nullptr);
    auto clone_vec = clone->getArguments(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto obj = getTypespec())
    clone->setTypespec(obj->deepClone(clone, context));

  return clone;
}

TFCall* MethodFuncCall::deepClone(BaseClass* parent,
                                  CloneContext* context) const {
  ElaboratorContext* const elaboratorContext =
      clonecontext_cast<ElaboratorContext>(context);
  const Expr* prefix = getPrefix();
  if (prefix) {
    prefix = prefix->deepClone((BaseClass*)this, context);
  }
  bool is_function =
      elaboratorContext->m_elaborator.isFunctionCall(getName(), prefix);
  TFCall* the_clone = nullptr;
  if (is_function) {
    MethodFuncCall* const clone = context->m_serializer->make<MethodFuncCall>();
    the_clone = clone;
    const uint32_t id = clone->getUhdmId();
    *clone = *this;
    clone->setUhdmId(id);
    clone->setParent(parent);
    if (auto obj = getPrefix())
      clone->setPrefix(obj->deepClone(clone, context));
    const RefObj* ref = any_cast<RefObj>(clone->getPrefix());
    const ClassVar* varprefix = nullptr;
    if (ref) varprefix = any_cast<ClassVar>(ref->getActual());
    elaboratorContext->m_elaborator.scheduleTaskFuncBinding(clone, varprefix);
    Any* pushedVar = nullptr;
    if (auto vec = getArguments()) {
      clone->setArguments(nullptr);
      auto clone_vec = clone->getArguments(true);
      for (auto obj : *vec) {
        Any* arg = obj->deepClone(clone, context);
        // CB callbacks_to_append[$];
        // unique_callbacks_to_append = callbacks_to_append.unique( cb_ )
        // with ( cb_.get_inst_id );
        if (parent->getUhdmType() == UhdmType::HierPath) {
          HierPath* phier = (HierPath*)parent;
          Any* last = phier->getPathElems()->back();
          if (RefObj* last_ref = any_cast<RefObj>(last)) {
            if (const Any* actual = last_ref->getActual()) {
              if (RefObj* refarg = any_cast<RefObj>(arg)) {
                bool override = false;
                if (const Any* act = refarg->getActual()) {
                  if (act->getName() == obj->getName()) {
                    override = true;
                  }
                } else {
                  override = true;
                }
                if (override) {
                  if (actual->getUhdmType() == UhdmType::ArrayVar) {
                    ArrayVar* arr = (ArrayVar*)actual;
                    if (arr->getVariables() && !arr->getVariables()->empty()) {
                      Variables* var = arr->getVariables()->front();
                      if (Variables* varclone =
                              (Variables*)clone_tree(var, context)) {
                        varclone->setName(obj->getName());
                        varclone->setParent(obj->getParent());
                        actual = varclone;
                        elaboratorContext->m_elaborator.pushVar(varclone);
                        pushedVar = varclone;
                      }
                    }
                  }
                  refarg->setActual((Any*)actual);
                }
              }
            }
          }
        }
        clone_vec->emplace_back(arg);
      }
    }
    if (auto obj = getWith()) clone->setWith(obj->deepClone(clone, context));
    if (pushedVar) {
      elaboratorContext->m_elaborator.popVar(pushedVar);
    }
    if (auto obj = getScope()) clone->setScope(obj->deepClone(clone, context));
    if (auto obj = getTypespec())
      clone->setTypespec(obj->deepClone(clone, context));
  } else {
    MethodTaskCall* const clone = context->m_serializer->make<MethodTaskCall>();
    the_clone = clone;
    const uint32_t id = clone->getUhdmId();
    //*clone = *this;
    clone->setName(getName());
    clone->setArguments(getArguments());
    clone->setUhdmId(id);
    clone->setParent(parent);
    clone->setFile(getFile());
    clone->setStartLine(getStartLine());
    clone->setStartColumn(getStartColumn());
    clone->setEndLine(getEndLine());
    clone->setEndColumn(getEndColumn());
    if (auto obj = getPrefix())
      clone->setPrefix(obj->deepClone(clone, context));
    const RefObj* ref = any_cast<RefObj>(clone->getPrefix());
    const ClassVar* varprefix = nullptr;
    if (ref) varprefix = any_cast<ClassVar>(ref->getActual());
    elaboratorContext->m_elaborator.scheduleTaskFuncBinding(clone, varprefix);
    if (auto obj = getWith()) clone->setWith(obj->deepClone(clone, context));
    if (auto obj = getScope()) clone->setScope(obj->deepClone(clone, context));
    if (auto vec = getArguments()) {
      clone->setArguments(nullptr);
      auto clone_vec = clone->getArguments(true);
      for (auto obj : *vec) {
        clone_vec->emplace_back(obj->deepClone(clone, context));
      }
    }
    if (auto obj = getTypespec())
      clone->setTypespec(obj->deepClone(clone, context));
  }
  return the_clone;
}

Constant* Constant::deepClone(BaseClass* parent, CloneContext* context) const {
  ElaboratorContext* const elaboratorContext =
      clonecontext_cast<ElaboratorContext>(context);
  if (elaboratorContext->m_elaborator.uniquifyTypespec() || (getSize() == -1)) {
    Constant* const clone = context->m_serializer->make<Constant>();
    const uint32_t id = clone->getUhdmId();
    *clone = *this;
    clone->setUhdmId(id);
    clone->setParent(parent);
    if (auto obj = getTypespec())
      clone->setTypespec(obj->deepClone(clone, context));
    return clone;
  } else {
    return (Constant*)this;
  }
}

TaggedPattern* TaggedPattern::deepClone(BaseClass* parent,
                                        CloneContext* context) const {
  ElaboratorContext* const elaboratorContext =
      clonecontext_cast<ElaboratorContext>(context);
  if (elaboratorContext->m_elaborator.uniquifyTypespec()) {
    TaggedPattern* const clone = context->m_serializer->make<TaggedPattern>();
    const uint32_t id = clone->getUhdmId();
    *clone = *this;
    clone->setUhdmId(id);
    clone->setParent(parent);
    if (auto obj = getTypespec())
      clone->setTypespec(obj->deepClone(clone, context));
    if (auto obj = getPattern())
      clone->setPattern(obj->deepClone(clone, context));
    return clone;
  } else {
    return (TaggedPattern*)this;
  }
}

TFCall* MethodTaskCall::deepClone(BaseClass* parent,
                                  CloneContext* context) const {
  ElaboratorContext* const elaboratorContext =
      clonecontext_cast<ElaboratorContext>(context);
  const Expr* prefix = getPrefix();
  if (prefix) {
    prefix = prefix->deepClone((BaseClass*)this, context);
  }
  bool is_task = elaboratorContext->m_elaborator.isTaskCall(getName(), prefix);
  TFCall* the_clone = nullptr;
  if (is_task) {
    MethodTaskCall* const clone = context->m_serializer->make<MethodTaskCall>();
    the_clone = clone;
    const uint32_t id = clone->getUhdmId();
    *clone = *this;
    clone->setUhdmId(id);
    clone->setParent(parent);
    if (auto obj = getPrefix())
      clone->setPrefix(obj->deepClone(clone, context));
    const RefObj* ref = any_cast<RefObj>(clone->getPrefix());
    const ClassVar* varprefix = nullptr;
    if (ref) varprefix = any_cast<ClassVar>(ref->getActual());
    elaboratorContext->m_elaborator.scheduleTaskFuncBinding(clone, varprefix);
    if (auto obj = getWith()) clone->setWith(obj->deepClone(clone, context));
    if (auto obj = getScope()) clone->setScope(obj->deepClone(clone, context));
    if (auto vec = getArguments()) {
      clone->setArguments(nullptr);
      auto clone_vec = clone->getArguments(true);
      for (auto obj : *vec) {
        clone_vec->emplace_back(obj->deepClone(clone, context));
      }
    }
    if (auto obj = getTypespec())
      clone->setTypespec(obj->deepClone(clone, context));
  } else {
    MethodFuncCall* const clone = context->m_serializer->make<MethodFuncCall>();
    the_clone = clone;
    const uint32_t id = clone->getUhdmId();
    //*clone = *this;
    clone->setName(getName());
    clone->setArguments(getArguments());
    clone->setUhdmId(id);
    clone->setParent(parent);
    clone->setFile(getFile());
    clone->setStartLine(getStartLine());
    clone->setStartColumn(getStartColumn());
    clone->setEndLine(getEndLine());
    clone->setEndColumn(getEndColumn());
    if (auto obj = getPrefix())
      clone->setPrefix(obj->deepClone(clone, context));
    const RefObj* ref = any_cast<RefObj>(clone->getPrefix());
    const ClassVar* varprefix = nullptr;
    if (ref) varprefix = any_cast<ClassVar>(ref->getActual());
    elaboratorContext->m_elaborator.scheduleTaskFuncBinding(clone, varprefix);
    if (auto obj = getWith()) clone->setWith(obj->deepClone(clone, context));
    if (auto obj = getScope()) clone->setScope(obj->deepClone(clone, context));
    if (auto vec = getArguments()) {
      clone->setArguments(nullptr);
      auto clone_vec = clone->getArguments(true);
      for (auto obj : *vec) {
        clone_vec->emplace_back(obj->deepClone(clone, context));
      }
    }
    if (auto obj = getTypespec())
      clone->setTypespec(obj->deepClone(clone, context));
  }
  return the_clone;
}

TFCall* FuncCall::deepClone(BaseClass* parent, CloneContext* context) const {
  ElaboratorContext* const elaboratorContext =
      clonecontext_cast<ElaboratorContext>(context);
  bool is_function =
      elaboratorContext->m_elaborator.isFunctionCall(getName(), nullptr);
  TFCall* the_clone = nullptr;
  if (is_function) {
    FuncCall* const clone = context->m_serializer->make<FuncCall>();
    the_clone = clone;
    const uint32_t id = clone->getUhdmId();
    *clone = *this;
    clone->setUhdmId(id);
    clone->setParent(parent);
    elaboratorContext->m_elaborator.scheduleTaskFuncBinding(clone, nullptr);
    if (auto obj = getScope()) clone->setScope(obj->deepClone(clone, context));
    if (auto vec = getArguments()) {
      clone->setArguments(nullptr);
      auto clone_vec = clone->getArguments(true);
      for (auto obj : *vec) {
        clone_vec->emplace_back(obj->deepClone(clone, context));
      }
    }
    if (auto obj = getTypespec())
      clone->setTypespec(obj->deepClone(clone, context));
  } else {
    TaskCall* const clone = context->m_serializer->make<TaskCall>();
    the_clone = clone;
    const uint32_t id = clone->getUhdmId();
    //*clone = *this;
    clone->setName(getName());
    clone->setArguments(getArguments());
    clone->setUhdmId(id);
    clone->setParent(parent);
    clone->setFile(getFile());
    clone->setStartLine(getStartLine());
    clone->setStartColumn(getStartColumn());
    clone->setEndLine(getEndLine());
    clone->setEndColumn(getEndColumn());
    elaboratorContext->m_elaborator.scheduleTaskFuncBinding(clone, nullptr);
    if (auto obj = getScope()) clone->setScope(obj->deepClone(clone, context));
    if (auto vec = getArguments()) {
      clone->setArguments(nullptr);
      auto clone_vec = clone->getArguments(true);
      for (auto obj : *vec) {
        clone_vec->emplace_back(obj->deepClone(clone, context));
      }
    }
    if (auto obj = getTypespec())
      clone->setTypespec(obj->deepClone(clone, context));
  }

  return the_clone;
}

TFCall* TaskCall::deepClone(BaseClass* parent, CloneContext* context) const {
  ElaboratorContext* const elaboratorContext =
      clonecontext_cast<ElaboratorContext>(context);
  bool is_task = elaboratorContext->m_elaborator.isTaskCall(getName(), nullptr);
  TFCall* the_clone = nullptr;
  if (is_task) {
    TaskCall* const clone = context->m_serializer->make<TaskCall>();
    the_clone = clone;
    const uint32_t id = clone->getUhdmId();
    *clone = *this;
    clone->setUhdmId(id);
    clone->setParent(parent);
    elaboratorContext->m_elaborator.scheduleTaskFuncBinding(clone, nullptr);
    if (auto obj = getScope()) clone->setScope(obj->deepClone(clone, context));
    if (auto vec = getArguments()) {
      clone->setArguments(nullptr);
      auto clone_vec = clone->getArguments(true);
      for (auto obj : *vec) {
        clone_vec->emplace_back(obj->deepClone(clone, context));
      }
    }
    if (auto obj = getTypespec())
      clone->setTypespec(obj->deepClone(clone, context));
  } else {
    FuncCall* const clone = context->m_serializer->make<FuncCall>();
    the_clone = clone;
    const uint32_t id = clone->getUhdmId();
    //*clone = *this;
    clone->setName(getName());
    clone->setFile(getFile());
    clone->setStartLine(getStartLine());
    clone->setStartColumn(getStartColumn());
    clone->setEndLine(getEndLine());
    clone->setEndColumn(getEndColumn());
    clone->setArguments(getArguments());
    clone->setUhdmId(id);
    clone->setParent(parent);
    elaboratorContext->m_elaborator.scheduleTaskFuncBinding(clone, nullptr);
    if (auto obj = getScope()) clone->setScope(obj->deepClone(clone, context));
    if (auto vec = getArguments()) {
      clone->setArguments(nullptr);
      auto clone_vec = clone->getArguments(true);
      for (auto obj : *vec) {
        clone_vec->emplace_back(obj->deepClone(clone, context));
      }
    }
    if (auto obj = getTypespec())
      clone->setTypespec(obj->deepClone(clone, context));
  }
  return the_clone;
}

GenScopeArray* GenScopeArray::deepClone(BaseClass* parent,
                                        CloneContext* context) const {
  ElaboratorContext* const elaboratorContext =
      clonecontext_cast<ElaboratorContext>(context);
  GenScopeArray* const clone = context->m_serializer->make<GenScopeArray>();
  const uint32_t id = clone->getUhdmId();
  *clone = *this;
  clone->setUhdmId(id);
  clone->setParent(parent);
  if (auto obj = getGenVar()) clone->setGenVar(obj->deepClone(clone, context));
  if (auto vec = getGenScopes()) {
    clone->setGenScopes(nullptr);
    auto clone_vec = clone->getGenScopes(true);
    for (auto obj : *vec) {
      elaboratorContext->m_elaborator.enterGenScope(obj, nullptr);
      clone_vec->emplace_back(obj->deepClone(clone, context));
      elaboratorContext->m_elaborator.leaveGenScope(obj, nullptr);
    }
  }
  if (auto obj = getInstance())
    clone->setInstance(obj->deepClone(clone, context));

  return clone;
}

Function* Function::deepClone(BaseClass* parent, CloneContext* context) const {
  ElaboratorContext* const elaboratorContext =
      clonecontext_cast<ElaboratorContext>(context);
  Function* const clone = context->m_serializer->make<Function>();
  const uint32_t id = clone->getUhdmId();
  *clone = *this;
  clone->setUhdmId(id);
  clone->setParent(parent);
  if (auto obj = getLeftExpr())
    clone->setLeftExpr(obj->deepClone(clone, context));
  if (auto obj = getRightExpr())
    clone->setRightExpr(obj->deepClone(clone, context));
  if (auto obj = getReturn()) clone->setReturn((RefTypespec*)obj);
  if (auto obj = getInstance()) clone->setInstance((Instance*)obj);
  if (Instance* inst = any_cast<Instance>(parent)) clone->setInstance(inst);
  if (auto obj = getClassDefn())
    clone->setClassDefn(obj->deepClone(clone, context));
  if (auto vec = getIODecls()) {
    clone->setIODecls(nullptr);
    auto clone_vec = clone->getIODecls(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getVariables()) {
    clone->setVariables(nullptr);
    auto clone_vec = clone->getVariables(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getParameters()) {
    clone->setParameters(nullptr);
    auto clone_vec = clone->getParameters(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getInternalScopes()) {
    clone->setInternalScopes(nullptr);
    auto clone_vec = clone->getInternalScopes(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getTypespecs()) {
    clone->setTypespecs(nullptr);
    auto clone_vec = clone->getTypespecs(true);
    for (auto obj : *vec) {
      if (elaboratorContext->m_elaborator.uniquifyTypespec()) {
        clone_vec->emplace_back(obj->deepClone(clone, context));
      } else {
        clone_vec->emplace_back(obj);
      }
    }
  }
  elaboratorContext->m_elaborator.enterTaskFunc(clone, nullptr);
  if (auto vec = getConcurrentAssertions()) {
    clone->setConcurrentAssertions(nullptr);
    auto clone_vec = clone->getConcurrentAssertions(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getPropertyDecls()) {
    clone->setPropertyDecls(nullptr);
    auto clone_vec = clone->getPropertyDecls(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getSequenceDecls()) {
    clone->setSequenceDecls(nullptr);
    auto clone_vec = clone->getSequenceDecls(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getNamedEvents()) {
    clone->setNamedEvents(nullptr);
    auto clone_vec = clone->getNamedEvents(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getNamedEventArrays()) {
    clone->setNamedEventArrays(nullptr);
    auto clone_vec = clone->getNamedEventArrays(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getVirtualInterfaceVars()) {
    clone->setVirtualInterfaceVars(nullptr);
    auto clone_vec = clone->getVirtualInterfaceVars(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getRegs()) {
    clone->setRegs(nullptr);
    auto clone_vec = clone->getRegs(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getRegArrays()) {
    clone->setRegArrays(nullptr);
    auto clone_vec = clone->getRegArrays(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getMemorys()) {
    clone->setMemorys(nullptr);
    auto clone_vec = clone->getMemorys(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getParamAssigns()) {
    clone->setParamAssigns(nullptr);
    auto clone_vec = clone->getParamAssigns(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getLetDecls()) {
    clone->setLetDecls(nullptr);
    auto clone_vec = clone->getLetDecls(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getAttributes()) {
    clone->setAttributes(nullptr);
    auto clone_vec = clone->getAttributes(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getInstanceItems()) {
    clone->setInstanceItems(nullptr);
    auto clone_vec = clone->getInstanceItems(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto obj = getStmt()) clone->setStmt(obj->deepClone(clone, context));
  elaboratorContext->m_elaborator.leaveTaskFunc(clone, nullptr);
  return clone;
}

Task* Task::deepClone(BaseClass* parent, CloneContext* context) const {
  ElaboratorContext* const elaboratorContext =
      clonecontext_cast<ElaboratorContext>(context);
  Task* const clone = context->m_serializer->make<Task>();
  const uint32_t id = clone->getUhdmId();
  *clone = *this;
  clone->setUhdmId(id);
  clone->setParent(parent);
  if (auto obj = getLeftExpr())
    clone->setLeftExpr(obj->deepClone(clone, context));
  if (auto obj = getRightExpr())
    clone->setRightExpr(obj->deepClone(clone, context));
  if (auto obj = getReturn()) clone->setReturn(obj->deepClone(clone, context));
  if (auto obj = getInstance()) clone->setInstance((Instance*)obj);
  if (Instance* inst = any_cast<Instance>(parent)) clone->setInstance(inst);
  if (auto obj = getClassDefn())
    clone->setClassDefn(obj->deepClone(clone, context));
  if (auto vec = getIODecls()) {
    clone->setIODecls(nullptr);
    auto clone_vec = clone->getIODecls(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getVariables()) {
    clone->setVariables(nullptr);
    auto clone_vec = clone->getVariables(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getInternalScopes()) {
    clone->setInternalScopes(nullptr);
    auto clone_vec = clone->getInternalScopes(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getTypespecs()) {
    clone->setTypespecs(nullptr);
    auto clone_vec = clone->getTypespecs(true);
    for (auto obj : *vec) {
      if (elaboratorContext->m_elaborator.uniquifyTypespec()) {
        clone_vec->emplace_back(obj->deepClone(clone, context));
      } else {
        clone_vec->emplace_back(obj);
      }
    }
  }
  elaboratorContext->m_elaborator.enterTaskFunc(clone, nullptr);
  if (auto vec = getConcurrentAssertions()) {
    clone->setConcurrentAssertions(nullptr);
    auto clone_vec = clone->getConcurrentAssertions(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getPropertyDecls()) {
    clone->setPropertyDecls(nullptr);
    auto clone_vec = clone->getPropertyDecls(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getSequenceDecls()) {
    clone->setSequenceDecls(nullptr);
    auto clone_vec = clone->getSequenceDecls(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getNamedEvents()) {
    clone->setNamedEvents(nullptr);
    auto clone_vec = clone->getNamedEvents(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getNamedEventArrays()) {
    clone->setNamedEventArrays(nullptr);
    auto clone_vec = clone->getNamedEventArrays(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getVirtualInterfaceVars()) {
    clone->setVirtualInterfaceVars(nullptr);
    auto clone_vec = clone->getVirtualInterfaceVars(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getRegs()) {
    clone->setRegs(nullptr);
    auto clone_vec = clone->getRegs(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getRegArrays()) {
    clone->setRegArrays(nullptr);
    auto clone_vec = clone->getRegArrays(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getMemorys()) {
    clone->setMemorys(nullptr);
    auto clone_vec = clone->getMemorys(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getParamAssigns()) {
    clone->setParamAssigns(nullptr);
    auto clone_vec = clone->getParamAssigns(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getLetDecls()) {
    clone->setLetDecls(nullptr);
    auto clone_vec = clone->getLetDecls(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getAttributes()) {
    clone->setAttributes(nullptr);
    auto clone_vec = clone->getAttributes(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getParameters()) {
    clone->setParameters(nullptr);
    auto clone_vec = clone->getParameters(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto vec = getInstanceItems()) {
    clone->setInstanceItems(nullptr);
    auto clone_vec = clone->getInstanceItems(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto obj = getStmt()) clone->setStmt(obj->deepClone(clone, context));
  elaboratorContext->m_elaborator.leaveTaskFunc(clone, nullptr);
  return clone;
}

ContAssign* ContAssign::deepClone(BaseClass* parent,
                                  CloneContext* context) const {
  ElaboratorContext* const elaboratorContext =
      clonecontext_cast<ElaboratorContext>(context);
  ContAssign* const clone = context->m_serializer->make<ContAssign>();
  const uint32_t id = clone->getUhdmId();
  *clone = *this;
  clone->setUhdmId(id);
  clone->setParent(parent);
  if (auto obj = getDelay()) clone->setDelay(obj->deepClone(clone, context));
  Expr* lhs = nullptr;
  if (auto obj = getLhs()) {
    lhs = obj->deepClone(clone, context);
    if (lhs->getUhdmType() == UhdmType::HierPath) {
      HierPath* path = (HierPath*)lhs;
      Any* last = path->getPathElems()->back();
      if (RefObj* ro = any_cast<RefObj>(last)) {
        if (Net* n = any_cast<Net>(ro->getActual())) {
          // The net parent has to be the same as a current scope
          if (n->getParent() == parent) lhs = n;
        }
      }
    }
    clone->setLhs(lhs);
  }
  if (auto obj = getRhs()) {
    Expr* rhs = obj->deepClone(clone, context);
    if (rhs->getUhdmType() == UhdmType::HierPath) {
      HierPath* path = (HierPath*)rhs;
      Any* last = path->getPathElems()->back();
      if (RefObj* ro = any_cast<RefObj>(last)) {
        if (Constant* c = any_cast<Constant>(ro->getActual())) {
          // The constant parrent's parent has to be the same as a current scope
          if (c->getParent()->getParent() == parent) rhs = c;
        }
      }
    }
    clone->setRhs(rhs);
    if (RefObj* ro = any_cast<RefObj>(lhs)) {
      if (StructVar* stv = ro->getActual<StructVar>()) {
        if (RefTypespec* rt = stv->getTypespec()) {
          if (Typespec* ts = rt->getActual()) {
            ExprEval eval(elaboratorContext->m_elaborator.muteErrors());
            if (Expr* res = eval.flattenPatternAssignments(
                    *context->m_serializer, ts, rhs)) {
              if (res->getUhdmType() == UhdmType::Operation) {
                ((Operation*)rhs)
                    ->setOperands(((Operation*)res)->getOperands());
              }
            }
          }
        }
      }
    }
  }
  if (auto vec = getBits()) {
    clone->setBits(nullptr);
    auto clone_vec = clone->getBits(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }

  return clone;
}

Any* bindClassTypespec(ClassTypespec* ctps, Any* current, std::string_view name,
                       bool& found) {
  Any* previous = nullptr;
  const ClassDefn* defn = ctps->getClassDefn();
  while (defn) {
    if (defn->getVariables()) {
      for (Variables* var : *defn->getVariables()) {
        if (var->getName() == name) {
          if (RefObj* ro = any_cast<RefObj>(current)) {
            ro->setActual(var);
          }
          previous = var;
          found = true;
          break;
        }
      }
    }
    if (defn->getNamedEvents()) {
      for (NamedEvent* event : *defn->getNamedEvents()) {
        if (event->getName() == name) {
          if (RefObj* ro = any_cast<RefObj>(current)) {
            ro->setActual(event);
          }
          previous = event;
          found = true;
          break;
        }
      }
    }
    if (defn->getMethods()) {
      for (TaskFunc* tf : *defn->getMethods()) {
        if (tf->getName() == name) {
          if (RefObj* ro = any_cast<RefObj>(current)) {
            ro->setActual(tf);
          } else if (current->getUhdmType() == UhdmType::MethodFuncCall) {
            if (tf->getUhdmType() == UhdmType::Function)
              ((MethodFuncCall*)current)->setFunction((Function*)tf);
          } else if (current->getUhdmType() == UhdmType::MethodTaskCall) {
            if (tf->getUhdmType() == UhdmType::Task)
              ((MethodTaskCall*)current)->setTask((Task*)tf);
          }
          previous = tf;
          found = true;
          break;
        }
      }
    }
    if (found) break;

    const ClassDefn* base_defn = nullptr;
    if (const Extends* ext = defn->getExtends()) {
      if (const RefTypespec* rt = ext->getClassTypespec()) {
        if (const ClassTypespec* tp = rt->getActual<ClassTypespec>()) {
          base_defn = tp->getClassDefn();
        }
      }
    }
    defn = base_defn;
  }
  return previous;
}

HierPath* HierPath::deepClone(BaseClass* parent, CloneContext* context) const {
  ElaboratorContext* const elaboratorContext =
      clonecontext_cast<ElaboratorContext>(context);
  HierPath* const clone = context->m_serializer->make<HierPath>();
  const uint32_t id = clone->getUhdmId();
  *clone = *this;
  clone->setUhdmId(id);
  clone->setParent(parent);
  if (auto vec = getPathElems()) {
    clone->setPathElems(nullptr);
    auto clone_vec = clone->getPathElems(true);
    Any* previous = nullptr;
    for (auto obj : *vec) {
      Any* current = obj->deepClone(clone, context);
      clone_vec->emplace_back(current);
      bool found = false;
      if (RefObj* ref = any_cast<RefObj>(current)) {
        if (current->getName() == "this") {
          const Any* tmp = current;
          while (tmp) {
            if (tmp->getUhdmType() == UhdmType::ClassDefn) {
              ref->setActual((Any*)tmp);
              found = true;
              break;
            }
            tmp = tmp->getParent();
          }
        } else if (current->getName() == "super") {
          const Any* tmp = current;
          while (tmp) {
            if (tmp->getUhdmType() == UhdmType::ClassDefn) {
              ClassDefn* def = (ClassDefn*)tmp;
              if (const Extends* ext = def->getExtends()) {
                if (const RefTypespec* rt = ext->getClassTypespec()) {
                  if (const ClassTypespec* ctps =
                          rt->getActual<ClassTypespec>()) {
                    ref->setActual((Any*)ctps->getClassDefn());
                    found = true;
                    break;
                  }
                }
              }
              break;
            }
            tmp = tmp->getParent();
          }
        }
      }
      if (previous) {
        std::string_view name = obj->getName();
        if (name.empty() || name.find('[') == 0) {
          if (RefObj* ro = any_cast<RefObj>(obj)) {
            if (const Any* actual = ro->getActual()) {
              name = actual->getName();
            }
            //  a[i][j]
            if (previous->getUhdmType() == UhdmType::BitSelect) {
              BitSelect* prev = (BitSelect*)previous;
              ro->setActual((Any*)prev->getActual());
              found = true;
            }
          }
        }
        std::string nameIndexed(name);
        if (obj->getUhdmType() == UhdmType::BitSelect) {
          BitSelect* bs = static_cast<BitSelect*>(obj);
          const Expr* index = bs->getIndex();
          std::string_view indexName = index->getDecompile();
          if (!indexName.empty()) {
            nameIndexed.append("[").append(indexName).append("]");
          }
        }
        if (RefObj* pro = any_cast<RefObj>(previous)) {
          const Any* actual = pro->getActual();
          if ((actual == nullptr) && (previous->getName() == "$root")) {
            actual = elaboratorContext->m_elaborator.currentDesign();
          }
          if (actual) {
            UhdmType actual_type = actual->getUhdmType();
            switch (actual_type) {
              case UhdmType::Design: {
                Design* scope = (Design*)actual;
                if (scope->getTopModules()) {
                  for (auto m : *scope->getTopModules()) {
                    const std::string_view modName = m->getName();
                    if (modName == name || modName == nameIndexed ||
                        modName == std::string("work@").append(name)) {
                      found = true;
                      previous = m;
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(m);
                      }
                      break;
                    }
                  }
                }
                break;
              }
              case UhdmType::GenScope: {
                GenScope* scope = (GenScope*)actual;
                if (obj->getUhdmType() == UhdmType::MethodFuncCall) {
                  MethodFuncCall* call = (MethodFuncCall*)current;
                  if (scope->getTaskFuncs()) {
                    for (auto tf : *scope->getTaskFuncs()) {
                      if (tf->getName() == name) {
                        call->setFunction(any_cast<Function>(tf));
                        previous = (Any*)call->getFunction();
                        found = true;
                        break;
                      }
                    }
                  }
                } else if (obj->getUhdmType() == UhdmType::MethodTaskCall) {
                  MethodTaskCall* call = (MethodTaskCall*)current;
                  if (scope->getTaskFuncs()) {
                    for (auto tf : *scope->getTaskFuncs()) {
                      if (tf->getName() == name) {
                        call->setTask(any_cast<Task>(tf));
                        found = true;
                        previous = (Any*)call->getTask();
                        break;
                      }
                    }
                  }
                } else {
                  if (!found && scope->getModules()) {
                    for (auto m : *scope->getModules()) {
                      if (m->getName() == name || m->getName() == nameIndexed) {
                        found = true;
                        previous = m;
                        if (RefObj* cro = any_cast<RefObj>(current)) {
                          cro->setActual(m);
                        }
                        break;
                      }
                    }
                  }
                  if (!found && scope->getNets()) {
                    for (auto m : *scope->getNets()) {
                      if (m->getName() == name || m->getName() == nameIndexed) {
                        found = true;
                        previous = m;
                        if (RefObj* cro = any_cast<RefObj>(current)) {
                          cro->setActual(m);
                        }
                        break;
                      }
                    }
                  }
                  if (!found && scope->getArrayNets()) {
                    for (auto m : *scope->getArrayNets()) {
                      if (m->getName() == name || m->getName() == nameIndexed) {
                        found = true;
                        previous = m;
                        if (RefObj* cro = any_cast<RefObj>(current)) {
                          cro->setActual(m);
                        }
                        break;
                      }
                    }
                  }
                  if (!found && scope->getVariables()) {
                    for (auto m : *scope->getVariables()) {
                      if (m->getName() == name || m->getName() == nameIndexed) {
                        found = true;
                        previous = m;
                        if (RefObj* cro = any_cast<RefObj>(current)) {
                          cro->setActual(m);
                        }
                        break;
                      }
                    }
                  }
                  if (!found && scope->getGenScopeArrays()) {
                    for (auto gsa : *scope->getGenScopeArrays()) {
                      if (gsa->getName() == name ||
                          gsa->getName() == nameIndexed) {
                        if (!gsa->getGenScopes()->empty()) {
                          auto gs = gsa->getGenScopes()->front();
                          if (RefObj* cro = any_cast<RefObj>(current)) {
                            cro->setActual(gs);
                          }
                          previous = gs;
                          found = true;
                        }
                      }
                    }
                  }
                }
                break;
              }
              case UhdmType::Modport: {
                Modport* mp = (Modport*)actual;
                if (mp->getIODecls()) {
                  for (IODecl* decl : *mp->getIODecls()) {
                    if (decl->getName() == name) {
                      found = true;
                      previous = decl;
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(decl);
                      }
                    }
                  }
                }
                break;
              }
              case UhdmType::NamedEvent: {
                if (name == "triggered") {
                  // Builtin
                  found = true;
                }
                break;
              }
              case UhdmType::ArrayNet: {
                ArrayNet* anet = (ArrayNet*)actual;
                NetCollection* vars = anet->getNets();
                if (vars && vars->size()) {
                  actual = vars->at(0);
                  actual_type = actual->getUhdmType();
                }
                if (name == "size" || name == "exists" || name == "find" ||
                    name == "max" || name == "min") {
                  FuncCall* call = context->m_serializer->make<FuncCall>();
                  call->setName(name);
                  call->setParent(clone);
                  if (RefObj* cro = any_cast<RefObj>(current)) {
                    cro->setActual(call);
                  }
                  // Builtin method
                  found = true;
                  previous = (Any*)call;
                } else if (name == "") {
                  // One of the Index(es)
                  found = true;
                }
                break;
              }
              case UhdmType::ArrayVar:
              case UhdmType::PackedArrayVar: {
                const Typespec* tps = nullptr;
                if (actual_type == UhdmType::PackedArrayVar) {
                  PackedArrayVar* avar = (PackedArrayVar*)actual;
                  if (AnyCollection* vars = avar->getElements()) {
                    if (!vars->empty()) {
                      actual = vars->front();
                      actual_type = actual->getUhdmType();
                    }
                  }
                  if (const RefTypespec* rt = avar->getTypespec()) {
                    tps = rt->getActual();
                    if (const PackedArrayTypespec* ptps =
                            rt->getActual<PackedArrayTypespec>()) {
                      if (const RefTypespec* ert = ptps->getElemTypespec()) {
                        tps = ert->getActual();
                      }
                    }
                  }
                } else {
                  ArrayVar* avar = (ArrayVar*)actual;
                  if (VariablesCollection* vars = avar->getVariables()) {
                    if (!vars->empty()) {
                      actual = vars->front();
                      actual_type = actual->getUhdmType();
                    }
                  }
                  if (const RefTypespec* rt = avar->getTypespec()) {
                    tps = rt->getActual();
                    if (const ArrayTypespec* atps =
                            rt->getActual<ArrayTypespec>()) {
                      if (const RefTypespec* ert = atps->getElemTypespec()) {
                        tps = ert->getActual();
                      }
                    }
                  }
                }
                if (name == "size" || name == "exists" || name == "find" ||
                    name == "max" || name == "min") {
                  FuncCall* call = context->m_serializer->make<FuncCall>();
                  call->setName(name);
                  call->setParent(clone);
                  if (RefObj* cro = any_cast<RefObj>(current)) {
                    cro->setActual(call);
                  }
                  // Builtin method
                  found = true;
                  previous = (Any*)call;
                }
                if (found == false) {
                  if (tps) {
                    UhdmType ttype = tps->getUhdmType();
                    if (ttype == UhdmType::PackedArrayTypespec) {
                      PackedArrayTypespec* ptps = (PackedArrayTypespec*)tps;
                      tps = (Typespec*)ptps->getElemTypespec();
                      if (tps) ttype = tps->getUhdmType();
                    } else if (ttype == UhdmType::ArrayTypespec) {
                      ArrayTypespec* ptps = (ArrayTypespec*)tps;
                      tps = (Typespec*)ptps->getElemTypespec();
                      if (tps) ttype = tps->getUhdmType();
                    }
                    if (ttype == UhdmType::StringTypespec) {
                      found = true;
                    } else if (ttype == UhdmType::ClassTypespec) {
                      ClassTypespec* ctps = (ClassTypespec*)tps;
                      Any* tmp = bindClassTypespec(ctps, current, name, found);
                      if (found) {
                        previous = tmp;
                      }
                    } else if (ttype == UhdmType::StructTypespec) {
                      StructTypespec* stpt = (StructTypespec*)tps;
                      for (TypespecMember* member : *stpt->getMembers()) {
                        if (member->getName() == name) {
                          if (RefObj* cro = any_cast<RefObj>(current)) {
                            cro->setActual(member);
                          }
                          previous = member;
                          found = true;
                          break;
                        }
                      }
                      if (name == "name") {
                        // Builtin introspection
                        found = true;
                      }
                    } else if (ttype == UhdmType::EnumTypespec) {
                      if (name == "name") {
                        // Builtin introspection
                        found = true;
                      }
                    } else if (ttype == UhdmType::UnionTypespec) {
                      UnionTypespec* stpt = (UnionTypespec*)tps;
                      for (TypespecMember* member : *stpt->getMembers()) {
                        if (member->getName() == name) {
                          if (RefObj* cro = any_cast<RefObj>(current)) {
                            cro->setActual(member);
                          }
                          previous = member;
                          found = true;
                          break;
                        }
                      }
                      if (name == "name") {
                        // Builtin introspection
                        found = true;
                      }
                    }
                  }
                }
                break;
              }
              case UhdmType::PackedArrayNet: {
                PackedArrayNet* avar = (PackedArrayNet*)actual;
                AnyCollection* vars = avar->getElements();
                if (vars && vars->size()) {
                  actual = vars->at(0);
                  actual_type = actual->getUhdmType();
                }
                if (name == "size" || name == "exists" || name == "exists" ||
                    name == "max" || name == "min") {
                  FuncCall* call = context->m_serializer->make<FuncCall>();
                  call->setName(name);
                  call->setParent(clone);
                  if (RefObj* cro = any_cast<RefObj>(current)) {
                    cro->setActual(call);
                  }
                  // Builtin method
                  found = true;
                  previous = (Any*)call;
                }
                break;
              }
              default:
                break;
            }

            switch (actual_type) {
              case UhdmType::ClockingBlock: {
                ClockingBlock* block = (ClockingBlock*)actual;
                if (block->getClockingIODecls()) {
                  for (ClockingIODecl* decl : *block->getClockingIODecls()) {
                    if (decl->getName() == name) {
                      found = true;
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(decl);
                      }
                    }
                  }
                }
                break;
              }
              case UhdmType::Module: {
                Module* mod = (Module*)actual;
                if (!found && mod->getVariables()) {
                  for (Variables* var : *mod->getVariables()) {
                    if (var->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(var);
                      }
                      previous = var;
                      found = true;
                      break;
                    }
                  }
                }
                if (!found && mod->getNets()) {
                  for (Nets* n : *mod->getNets()) {
                    if (n->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(n);
                      }
                      previous = n;
                      found = true;
                      break;
                    }
                  }
                }
                if (!found && mod->getModules()) {
                  for (auto m : *mod->getModules()) {
                    if (m->getName() == name || m->getName() == nameIndexed) {
                      found = true;
                      previous = m;
                      break;
                    }
                  }
                }
                if (!found && mod->getInterfaces()) {
                  for (auto m : *mod->getInterfaces()) {
                    if (m->getName() == name || m->getName() == nameIndexed) {
                      found = true;
                      previous = m;
                      break;
                    }
                  }
                }
                if (!found && mod->getGenScopeArrays()) {
                  for (auto gsa : *mod->getGenScopeArrays()) {
                    if (gsa->getName() == name ||
                        gsa->getName() == nameIndexed) {
                      if (!gsa->getGenScopes()->empty()) {
                        auto gs = gsa->getGenScopes()->front();
                        if (RefObj* cro = any_cast<RefObj>(current)) {
                          cro->setActual(gs);
                        }
                        previous = gs;
                        found = true;
                      }
                    }
                  }
                }
                if (!found && mod->getTaskFuncs()) {
                  for (auto tsf : *mod->getTaskFuncs()) {
                    if (tsf->getName() == name ||
                        tsf->getName() == nameIndexed) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(tsf);
                      }
                      previous = tsf;
                      found = true;
                    }
                  }
                }
                if (!found && mod->getParamAssigns()) {
                  for (auto pa : *mod->getParamAssigns()) {
                    if (pa->getLhs()->getName() == name ||
                        pa->getLhs()->getName() == nameIndexed) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(pa->getRhs());
                      }
                      previous = pa;
                      found = true;
                    }
                  }
                }
                break;
              }
              case UhdmType::ClassVar: {
                const Typespec* tps = nullptr;
                if (const RefTypespec* rt =
                        ((ClassVar*)actual)->getTypespec()) {
                  tps = rt->getActual();
                }
                if (tps == nullptr) break;
                UhdmType ttype = tps->getUhdmType();
                if (ttype == UhdmType::ClassTypespec) {
                  ClassTypespec* ctps = (ClassTypespec*)tps;
                  Any* tmp = bindClassTypespec(ctps, current, name, found);
                  if (found) {
                    previous = tmp;
                  }
                } else if (ttype == UhdmType::StructTypespec) {
                  StructTypespec* stpt = (StructTypespec*)tps;
                  for (TypespecMember* member : *stpt->getMembers()) {
                    if (member->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(member);
                      }
                      previous = member;
                      found = true;
                      break;
                    }
                  }
                }
                if (current->getUhdmType() == UhdmType::MethodFuncCall) {
                  found = true;
                }
                break;
              }
              case UhdmType::StructNet:
              case UhdmType::StructVar: {
                TypespecMemberCollection* members = nullptr;
                if (actual->getUhdmType() == UhdmType::StructNet) {
                  if (RefTypespec* rt = ((StructNet*)actual)->getTypespec()) {
                    if (StructTypespec* sts = rt->getActual<StructTypespec>()) {
                      members = sts->getMembers();
                    } else if (UnionTypespec* uts =
                                   rt->getActual<UnionTypespec>()) {
                      members = uts->getMembers();
                    }
                  }
                } else if (actual->getUhdmType() == UhdmType::StructVar) {
                  if (RefTypespec* rt = ((StructVar*)actual)->getTypespec()) {
                    if (StructTypespec* sts = rt->getActual<StructTypespec>()) {
                      members = sts->getMembers();
                    }
                  }
                }
                if (members) {
                  for (TypespecMember* member : *members) {
                    if (member->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(member);
                      }
                      previous = member;
                      found = true;
                      break;
                    }
                  }
                }
                break;
              }
              case UhdmType::UnionVar: {
                UnionTypespec* stpt = nullptr;
                if (RefTypespec* rt = ((UnionVar*)actual)->getTypespec()) {
                  stpt = rt->getActual<UnionTypespec>();
                }
                if (stpt == nullptr) break;
                for (TypespecMember* member : *stpt->getMembers()) {
                  if (member->getName() == name) {
                    if (RefObj* cro = any_cast<RefObj>(current)) {
                      cro->setActual(member);
                    }
                    previous = member;
                    found = true;
                    break;
                  }
                }
                break;
              }
              case UhdmType::Interface: {
                Interface* interf = (Interface*)actual;
                if (!found && interf->getVariables()) {
                  for (Variables* var : *interf->getVariables()) {
                    if (var->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(var);
                      }
                      previous = var;
                      found = true;
                      break;
                    }
                  }
                }
                if (!found && interf->getParameters()) {
                  for (Any* var : *interf->getParameters()) {
                    if (var->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(var);
                      }
                      previous = var;
                      found = true;
                      break;
                    }
                  }
                }
                if (!found && interf->getTaskFuncs()) {
                  for (auto tf : *interf->getTaskFuncs()) {
                    if (tf->getName() == name) {
                      previous = any_cast<Function>(tf);
                      found = true;
                      break;
                    }
                  }
                }
                if (!found && interf->getModports()) {
                  for (Modport* mport : *interf->getModports()) {
                    if (mport->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(mport);
                      }
                      previous = mport;
                      found = true;
                      break;
                    }
                    if (mport->getIODecls()) {
                      for (IODecl* decl : *mport->getIODecls()) {
                        if (decl->getName() == name) {
                          Any* actual_decl = decl;
                          if (Any* exp = decl->getExpr()) {
                            actual_decl = exp;
                          }
                          if (actual_decl->getUhdmType() == UhdmType::RefObj) {
                            RefObj* ref = (RefObj*)actual_decl;
                            if (const Any* act = ref->getActual()) {
                              actual_decl = (Any*)act;
                            }
                          }
                          if (RefObj* cro = any_cast<RefObj>(current)) {
                            cro->setActual(actual_decl);
                          }
                          previous = actual_decl;
                          found = true;
                          break;
                        }
                      }
                    }
                    if (found) break;
                  }
                }
                if (!found && interf->getNets()) {
                  for (Nets* n : *interf->getNets()) {
                    if (n->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(n);
                      }
                      previous = n;
                      found = true;
                      break;
                    }
                  }
                }
                if (!found && interf->getPorts()) {
                  for (Port* p : *interf->getPorts()) {
                    if (p->getName() == name) {
                      if (Any* ref = p->getLowConn()) {
                        if (RefObj* nref = any_cast<RefObj>(ref)) {
                          Any* n = nref->getActual();
                          if (RefObj* cro = any_cast<RefObj>(current)) {
                            cro->setActual(n);
                          }
                          previous = n;
                          found = true;
                          break;
                        }
                      }
                    }
                  }
                }
                if (!found && interf->getGenScopeArrays()) {
                  for (auto gsa : *interf->getGenScopeArrays()) {
                    if (gsa->getName() == name ||
                        gsa->getName() == nameIndexed) {
                      if (!gsa->getGenScopes()->empty()) {
                        auto gs = gsa->getGenScopes()->front();
                        if (RefObj* cro = any_cast<RefObj>(current)) {
                          cro->setActual(gs);
                        }
                        previous = gs;
                        found = true;
                      }
                    }
                  }
                }
                break;
              }
              case UhdmType::ArrayVar: {
                if (current->getUhdmType() == UhdmType::MethodFuncCall)
                  found = true;
                else if (current->getUhdmType() == UhdmType::BitSelect)
                  found = true;
                break;
              }
              case UhdmType::StringVar: {
                if (current->getUhdmType() == UhdmType::MethodFuncCall)
                  found = true;
                else if (current->getUhdmType() == UhdmType::BitSelect)
                  found = true;
                break;
              }
              case UhdmType::ClassTypespec: {
                ClassTypespec* ctps = (ClassTypespec*)actual;
                Any* tmp = bindClassTypespec(ctps, current, name, found);
                if (found) {
                  previous = tmp;
                }
                break;
              }
              case UhdmType::IODecl: {
                IODecl* decl = (IODecl*)actual;
                Typespec* tps = nullptr;
                if (RefTypespec* rt = decl->getTypespec()) {
                  tps = rt->getActual();
                }
                if (tps == nullptr) break;
                UhdmType ttype = tps->getUhdmType();
                if (ttype == UhdmType::StringTypespec) {
                  found = true;
                } else if (ttype == UhdmType::ClassTypespec) {
                  ClassTypespec* ctps = (ClassTypespec*)tps;
                  Any* tmp = bindClassTypespec(ctps, current, name, found);
                  if (found) {
                    previous = tmp;
                  }
                } else if (ttype == UhdmType::StructTypespec) {
                  StructTypespec* stpt = (StructTypespec*)tps;
                  for (TypespecMember* member : *stpt->getMembers()) {
                    if (member->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(member);
                      }
                      previous = member;
                      found = true;
                      break;
                    }
                  }
                  if (name == "name") {
                    // Builtin introspection
                    found = true;
                  }
                } else if (ttype == UhdmType::EnumTypespec) {
                  if (name == "name") {
                    // Builtin introspection
                    found = true;
                  }
                } else if (ttype == UhdmType::UnionTypespec) {
                  UnionTypespec* stpt = (UnionTypespec*)tps;
                  for (TypespecMember* member : *stpt->getMembers()) {
                    if (member->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(member);
                      }
                      previous = member;
                      found = true;
                      break;
                    }
                  }
                  if (name == "name") {
                    // Builtin introspection
                    found = true;
                  }
                }
                if (decl->getRanges()) {
                  if (current->getUhdmType() == UhdmType::MethodFuncCall)
                    found = true;
                  else if (current->getUhdmType() == UhdmType::BitSelect)
                    found = true;
                }
                // TODO: class method support
                if (current->getUhdmType() == UhdmType::MethodFuncCall)
                  found = true;
                break;
              }
              case UhdmType::Parameter: {
                Parameter* param = (Parameter*)actual;
                const Typespec* tps = nullptr;
                if (const RefTypespec* rt = param->getTypespec()) {
                  tps = rt->getActual();
                }
                if (tps == nullptr) break;
                UhdmType ttype = tps->getUhdmType();
                if (ttype == UhdmType::PackedArrayTypespec) {
                  PackedArrayTypespec* ptps = (PackedArrayTypespec*)tps;
                  if (const RefTypespec* ert = ptps->getElemTypespec()) {
                    if (const Typespec* ets = ert->getActual()) {
                      tps = ets;
                      ttype = ets->getUhdmType();
                    }
                  }
                } else if (ttype == UhdmType::ArrayTypespec) {
                  ArrayTypespec* ptps = (ArrayTypespec*)tps;
                  if (const RefTypespec* ert = ptps->getElemTypespec()) {
                    if (const Typespec* ets = ert->getActual()) {
                      tps = ets;
                      ttype = ets->getUhdmType();
                    }
                  }
                }
                if (ttype == UhdmType::StringTypespec) {
                  found = true;
                } else if (ttype == UhdmType::ClassTypespec) {
                  ClassTypespec* ctps = (ClassTypespec*)tps;
                  Any* tmp = bindClassTypespec(ctps, current, name, found);
                  if (found) {
                    previous = tmp;
                  }
                } else if (ttype == UhdmType::StructTypespec) {
                  StructTypespec* stpt = (StructTypespec*)tps;
                  for (TypespecMember* member : *stpt->getMembers()) {
                    if (member->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(member);
                      }
                      previous = member;
                      found = true;
                      break;
                    }
                  }
                  if (name == "name") {
                    // Builtin introspection
                    found = true;
                  }
                } else if (ttype == UhdmType::EnumTypespec) {
                  if (name == "name") {
                    // Builtin introspection
                    found = true;
                  }
                } else if (ttype == UhdmType::UnionTypespec) {
                  UnionTypespec* stpt = (UnionTypespec*)tps;
                  for (TypespecMember* member : *stpt->getMembers()) {
                    if (member->getName() == name) {
                      if (RefObj* cro = any_cast<RefObj>(current)) {
                        cro->setActual(member);
                      }
                      previous = member;
                      found = true;
                      break;
                    }
                  }
                  if (name == "name") {
                    // Builtin introspection
                    found = true;
                  }
                }
                if (param->getRanges()) {
                  if (current->getUhdmType() == UhdmType::MethodFuncCall)
                    found = true;
                  else if (current->getUhdmType() == UhdmType::BitSelect)
                    found = true;
                }
                break;
              }
              case UhdmType::Operation: {
                Operation* op = (Operation*)actual;
                if (op->getOpType() != vpiAssignmentPatternOp) {
                  break;
                }
                const StructTypespec* stps = nullptr;
                if (const RefTypespec* rt = op->getTypespec()) {
                  stps = rt->getActual<StructTypespec>();
                }
                if (stps == nullptr) break;
                std::vector<std::string_view> fieldNames;
                std::vector<const Typespec*> fieldTypes;
                for (TypespecMember* memb : *stps->getMembers()) {
                  if (const RefTypespec* rt = memb->getTypespec()) {
                    fieldNames.emplace_back(memb->getName());
                    fieldTypes.emplace_back(rt->getActual());
                  }
                }
                std::vector<Any*> tmp(fieldNames.size());
                AnyCollection* orig = op->getOperands();
                Any* defaultOp = nullptr;
                Any* res = nullptr;
                int32_t index = 0;
                for (auto oper : *orig) {
                  if (oper->getUhdmType() == UhdmType::TaggedPattern) {
                    TaggedPattern* tp = (TaggedPattern*)oper;
                    const Typespec* ttp = nullptr;
                    if (const RefTypespec* rt = tp->getTypespec()) {
                      ttp = rt->getActual();
                    }
                    const std::string_view tname = ttp->getName();
                    bool oper_found = false;
                    if (tname == "default") {
                      defaultOp = oper;
                      oper_found = true;
                    }
                    for (uint32_t i = 0; i < fieldNames.size(); i++) {
                      if (tname == fieldNames[i]) {
                        tmp[i] = oper;
                        oper_found = true;
                        res = tmp[i];
                        break;
                      }
                    }
                    if (oper_found == false) {
                      for (uint32_t i = 0; i < fieldTypes.size(); i++) {
                        if (ttp->getUhdmType() ==
                            fieldTypes[i]->getUhdmType()) {
                          tmp[i] = oper;
                          oper_found = true;
                          res = tmp[i];
                          break;
                        }
                      }
                    }
                  } else {
                    if (index < (int32_t)tmp.size()) {
                      tmp[index] = oper;
                      found = true;
                      res = tmp[index];
                    }
                  }
                  index++;
                }
                if (res == nullptr) {
                  if (defaultOp) {
                    res = defaultOp;
                  }
                }
                previous = res;
                break;
              }
              case UhdmType::RefVar: {
                found = true;
                // TODO: class var support
                break;
              }
              default:
                // TODO: class method support
                if (current->getUhdmType() == UhdmType::MethodFuncCall)
                  found = true;
                break;
            }
            if (!found) {
              if ((!elaboratorContext->m_elaborator.muteErrors()) &&
                  (!elaboratorContext->m_elaborator.isInUhdmAllIterator())) {
                const std::string errMsg(getName());
                context->m_serializer->getErrorHandler()(
                    ErrorType::UHDM_UNRESOLVED_HIER_PATH, errMsg, this,
                    nullptr);
              }
            }
          } else {
            if ((!elaboratorContext->m_elaborator.muteErrors()) &&
                (!elaboratorContext->m_elaborator.isInUhdmAllIterator())) {
              if (previous->getUhdmType() == UhdmType::BitSelect) {
                break;
              }
              const std::string errMsg(getName());
              context->m_serializer->getErrorHandler()(
                  ErrorType::UHDM_UNRESOLVED_HIER_PATH, errMsg, this, nullptr);
            }
          }
        } else if (previous->getUhdmType() == UhdmType::TypespecMember) {
          TypespecMember* member = (TypespecMember*)previous;
          const Typespec* tps = nullptr;
          if (const RefTypespec* rt = member->getTypespec()) {
            tps = rt->getActual();
          }
          if (tps == nullptr) break;
          UhdmType ttype = tps->getUhdmType();
          if (ttype == UhdmType::PackedArrayTypespec) {
            PackedArrayTypespec* ptps = (PackedArrayTypespec*)tps;
            if (const RefTypespec* rt = ptps->getElemTypespec()) {
              tps = rt->getActual();
              ttype = tps->getUhdmType();
            }
          } else if (ttype == UhdmType::ArrayTypespec) {
            ArrayTypespec* ptps = (ArrayTypespec*)tps;
            if (const RefTypespec* rt = ptps->getElemTypespec()) {
              tps = rt->getActual();
              ttype = tps->getUhdmType();
            }
          }
          if (ttype == UhdmType::StructTypespec) {
            StructTypespec* stpt = (StructTypespec*)tps;
            for (TypespecMember* tsmember : *stpt->getMembers()) {
              if (tsmember->getName() == name) {
                if (RefObj* cro = any_cast<RefObj>(current)) {
                  cro->setActual(tsmember);
                  previous = tsmember;
                  found = true;
                  break;
                }
              }
            }
          } else if (ttype == UhdmType::UnionTypespec) {
            UnionTypespec* stpt = (UnionTypespec*)tps;
            for (TypespecMember* tsmember : *stpt->getMembers()) {
              if (tsmember->getName() == name) {
                if (RefObj* cro = any_cast<RefObj>(current)) {
                  cro->setActual(tsmember);
                  previous = tsmember;
                  found = true;
                  break;
                }
              }
            }
          } else if (ttype == UhdmType::StringTypespec) {
            if (name == "len") {
              found = true;
            }
          }
        } else if (previous->getUhdmType() == UhdmType::ArrayVar) {
          ArrayVar* avar = (ArrayVar*)previous;
          if (VariablesCollection* vars = avar->getVariables()) {
            if (!vars->empty()) {
              Variables* actual = vars->front();
              UhdmType actual_type = actual->getUhdmType();
              switch (actual_type) {
                case UhdmType::StructNet:
                case UhdmType::StructVar: {
                  TypespecMemberCollection* members = nullptr;
                  if (actual->getUhdmType() == UhdmType::StructNet) {
                    if (RefTypespec* rt = ((StructNet*)actual)->getTypespec()) {
                      if (StructTypespec* sts =
                              rt->getActual<StructTypespec>()) {
                        members = sts->getMembers();
                      } else if (UnionTypespec* uts =
                                     rt->getActual<UnionTypespec>()) {
                        members = uts->getMembers();
                      }
                    }
                  } else if (actual->getUhdmType() == UhdmType::StructVar) {
                    if (RefTypespec* rt = ((StructVar*)actual)->getTypespec()) {
                      if (StructTypespec* sts =
                              rt->getActual<StructTypespec>()) {
                        members = sts->getMembers();
                      }
                    }
                  }
                  if (members) {
                    for (TypespecMember* member : *members) {
                      if (member->getName() == name) {
                        if (RefObj* cro = any_cast<RefObj>(current)) {
                          cro->setActual(member);
                        }
                        previous = member;
                        found = true;
                        break;
                      }
                    }
                  }
                  break;
                }
                default:
                  break;
              }
            }
          }
        } else if (previous->getUhdmType() == UhdmType::StructVar ||
                   previous->getUhdmType() == UhdmType::StructNet) {
          TypespecMemberCollection* members = nullptr;
          if (previous->getUhdmType() == UhdmType::StructNet) {
            if (RefTypespec* rt = ((StructNet*)previous)->getTypespec()) {
              if (StructTypespec* sts = rt->getActual<StructTypespec>()) {
                members = sts->getMembers();
              } else if (UnionTypespec* uts = rt->getActual<UnionTypespec>()) {
                members = uts->getMembers();
              }
            }
          } else if (previous->getUhdmType() == UhdmType::StructVar) {
            if (RefTypespec* rt = ((StructVar*)previous)->getTypespec()) {
              if (StructTypespec* sts = rt->getActual<StructTypespec>()) {
                members = sts->getMembers();
              }
            }
          }
          if (members) {
            for (TypespecMember* member : *members) {
              if (member->getName() == name) {
                if (RefObj* cro = any_cast<RefObj>(current)) {
                  cro->setActual(member);
                }
                previous = member;
                found = true;
                break;
              }
            }
          }
        } else if (previous->getUhdmType() == UhdmType::Module) {
          Module* mod = (Module*)previous;
          if (mod->getVariables()) {
            for (Variables* var : *mod->getVariables()) {
              if (var->getName() == name) {
                if (RefObj* cro = any_cast<RefObj>(current)) {
                  cro->setActual(var);
                }
                previous = var;
                found = true;
                break;
              }
            }
          }

          if (!found && mod->getNets()) {
            for (Nets* n : *mod->getNets()) {
              if (n->getName() == name) {
                if (RefObj* cro = any_cast<RefObj>(current)) {
                  cro->setActual(n);
                }
                previous = n;
                found = true;
                break;
              }
            }
          }
          if (!found && mod->getModules()) {
            for (auto m : *mod->getModules()) {
              if (m->getName() == name || m->getName() == nameIndexed) {
                found = true;
                previous = m;
                break;
              }
            }
          }
          break;
        } else if (previous->getUhdmType() == UhdmType::GenScope) {
          GenScope* scope = (GenScope*)previous;
          if (obj->getUhdmType() == UhdmType::MethodFuncCall) {
            MethodFuncCall* call = (MethodFuncCall*)current;
            if (scope->getTaskFuncs()) {
              for (auto tf : *scope->getTaskFuncs()) {
                if (tf->getName() == name) {
                  call->setFunction(any_cast<Function>(tf));
                  previous = (Any*)call->getFunction();
                  found = true;
                  break;
                }
              }
            }
          } else if (obj->getUhdmType() == UhdmType::MethodTaskCall) {
            MethodTaskCall* call = (MethodTaskCall*)current;
            if (scope->getTaskFuncs()) {
              for (auto tf : *scope->getTaskFuncs()) {
                if (tf->getName() == name) {
                  call->setTask(any_cast<Task>(tf));
                  found = true;
                  previous = (Any*)call->getTask();
                  break;
                }
              }
            }
          } else {
            if (scope->getModules()) {
              for (auto m : *scope->getModules()) {
                if (m->getName() == name || m->getName() == nameIndexed) {
                  found = true;
                  previous = m;
                  if (RefObj* cro = any_cast<RefObj>(current)) {
                    cro->setActual(m);
                  }
                  break;
                }
              }
            }
          }
        }
      }
      if (!found) previous = current;
    }
  }
  if (auto vec = getUses()) {
    clone->setUses(nullptr);
    auto clone_vec = clone->getUses(true);
    for (auto obj : *vec) {
      clone_vec->emplace_back(obj->deepClone(clone, context));
    }
  }
  if (auto obj = getTypespec())
    clone->setTypespec(obj->deepClone(clone, context));
  return clone;
}
}  // namespace uhdm
