/*
 Do not modify, auto-generated by script

 Copyright 2019 Alain Dargelas

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 * File:   BaseClass.cpp
 * Author:
 *
 * Created on January 04, 2021, 01:01 AM
 */
#include <uhdm/BaseClass.h>
#include <uhdm/Serializer.h>

namespace uhdm {
std::string_view BaseClass::getFile() const {
  return m_fileId ? m_serializer->getSymbol(m_fileId) : kEmpty;
}

bool BaseClass::setFile(std::string_view data) {
  m_fileId = m_serializer->makeSymbol(data);
  return true;
}

bool BaseClass::setParent(BaseClass* data, bool force /* = false */) {
  if (m_parent == data) return true;
  // Allow changing only from/to nullptr
  if (!force && !(((m_parent == nullptr) && (data != nullptr)) ||
                  ((m_parent != nullptr) && (data == nullptr))))
    return false;

  BaseClass* const oldParent = m_parent;

  m_parent = nullptr;
  if (oldParent != nullptr) oldParent->onChildRemoved(this);

  m_parent = data;
  if (m_parent != nullptr) m_parent->onChildAdded(this);

  return true;
}

const BaseClass* BaseClass::getByVpiName(std::string_view name) const {
  return nullptr;
}

BaseClass::get_by_vpi_type_return_t BaseClass::getByVpiType(
    int32_t type) const {
  switch (type) {
    case vpiParent:
      return get_by_vpi_type_return_t(static_cast<UhdmType>(0), m_parent,
                                      nullptr);
    default:
      return get_by_vpi_type_return_t(static_cast<UhdmType>(0), nullptr,
                                      nullptr);
  };
}

BaseClass::vpi_property_value_t BaseClass::getVpiPropertyValue(
    int32_t property) const {
  switch (property) {
    case vpiLineNo:
      return vpi_property_value_t(m_startLine);
    case vpiColumnNo:
      return vpi_property_value_t(m_startColumn);
    case vpiEndLineNo:
      return vpi_property_value_t(m_endLine);
    case vpiEndColumnNo:
      return vpi_property_value_t(m_endColumn);
    case vpiType:
      return vpi_property_value_t(getVpiType());
    case vpiFile: {
      const std::string_view file = getFile();
      if (!file.empty()) {
        return vpi_property_value_t(file.data());
      }
    } break;
    case vpiName: {
      const std::string_view name = getName();
      if (!name.empty()) {
        return vpi_property_value_t(name.data());
      }
    } break;
    case vpiDefName: {
      const std::string_view defname = getDefName();
      if (!defname.empty()) {
        return vpi_property_value_t(defname.data());
      }
    } break;
  }
  return vpi_property_value_t();
}

BaseClass* BaseClass::deepClone(BaseClass* parent,
                                CloneContext* context) const {
  return nullptr;
}

void BaseClass::deepCopy(BaseClass* clone, BaseClass* parent,
                         CloneContext* context) const {
  clone->setParent(parent);
}

std::string BaseClass::computeFullName() const {
  if ((getUhdmType() == UhdmType::Module) && (getParent() != nullptr) &&
      (getParent()->getUhdmType() == UhdmType::Module)) {
    return std::string(getDefName());
  }
  std::vector<std::string_view> names;
  const BaseClass* parent = this;
  const BaseClass* child = nullptr;
  bool column = false;
  while (parent != nullptr) {
    const BaseClass* actual_parent = parent->getParent();
    UhdmType parent_type =
        (parent != nullptr) ? parent->getUhdmType() : UhdmType::UnsupportedStmt;
    UhdmType actual_parent_type = (actual_parent != nullptr)
                                      ? actual_parent->getUhdmType()
                                      : UhdmType::UnsupportedStmt;
    if (parent_type == UhdmType::Design) break;
    if ((parent_type == UhdmType::Package) ||
        (parent_type == UhdmType::ClassDefn))
      column = true;
    std::string_view name =
        parent->getName().empty() ? parent->getDefName() : parent->getName();
    bool skip_name = (actual_parent_type == UhdmType::RefObj) ||
                     (parent_type == UhdmType::MethodFuncCall) ||
                     (parent_type == UhdmType::MethodTaskCall) ||
                     (parent_type == UhdmType::FuncCall) ||
                     (parent_type == UhdmType::TaskCall) ||
                     (parent_type == UhdmType::SysFuncCall) ||
                     (parent_type == UhdmType::SysTaskCall);
    if ((parent_type == UhdmType::Package) && !names.empty() && !name.empty()) {
      std::string scopeName(name);
      scopeName.append("::");
      if (names.back().find(scopeName) == 0) skip_name = true;
    }
    if (child != nullptr) {
      UhdmType child_type = child->getUhdmType();
      if ((child_type == UhdmType::BitSelect) &&
          (parent_type == UhdmType::Port)) {
        skip_name = true;
      }
      if ((child_type == UhdmType::RefObj) &&
          (parent_type == UhdmType::BitSelect)) {
        skip_name = true;
      }
      if ((child_type == UhdmType::RefObj) &&
          (parent_type == UhdmType::IndexedPartSelect)) {
        skip_name = true;
      }
      if ((child_type == UhdmType::RefObj) &&
          (parent_type == UhdmType::HierPath)) {
        skip_name = true;
      }
    }
    if ((!name.empty()) && (!skip_name)) {
      names.emplace_back(name);
    }
    child = parent;
    parent = parent->getParent();
  }
  std::string fullName;
  if (names.size() == 1) {
    fullName = names[0];
  } else if (!names.empty()) {
    size_t index = names.size() - 1;
    while (1) {
      fullName += names[index];
      if (index > 0) fullName += column ? "::" : ".";
      if (index == 0) break;
      index--;
    }
  }
  return fullName;
}

int32_t BaseClass::compare(const BaseClass* const other,
                           CompareContext* context) const {
  int32_t r = 0;

  const thistype_t* const lhs = this;
  const thistype_t* const rhs = other;

  if ((r = getVpiType() - rhs->getVpiType()) != 0) {
    context->m_failedLhs = lhs;
    context->m_failedRhs = rhs;
    return r;
  }
  if ((r = getName().compare(rhs->getName())) != 0) {
    context->m_failedLhs = lhs;
    context->m_failedRhs = rhs;
    return r;
  }
  if ((r = getDefName().compare(rhs->getDefName())) != 0) {
    context->m_failedLhs = lhs;
    context->m_failedRhs = rhs;
    return r;
  }

  return r;
}

void BaseClass::swap(const BaseClass* what, BaseClass* with) {
  // Do NOT call getParent(with) here because it invokes onChildXXX
  // causing edits to containers that are being iterated on the call stack.
  if (getParent() == what) m_parent = with;
}

void BaseClass::swap(
    const std::map<const BaseClass*, BaseClass*>& replacements) {
  for (auto [what, with] : replacements) {
    swap(what, with);
  }
}

}  // namespace uhdm
