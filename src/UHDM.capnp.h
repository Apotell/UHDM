// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: UHDM.capnp

#ifndef CAPNP_INCLUDED_fff7299129556877_
#define CAPNP_INCLUDED_fff7299129556877_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 5003
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(b2bce98887da19bc);
CAPNP_DECLARE_SCHEMA(c4de5d61fdda1fc2);
CAPNP_DECLARE_SCHEMA(809d8aea310cd2d3);
CAPNP_DECLARE_SCHEMA(f204710c1a739934);
CAPNP_DECLARE_SCHEMA(a0c61698af16b048);
CAPNP_DECLARE_SCHEMA(9227d3f15c9cc33f);
CAPNP_DECLARE_SCHEMA(f71f31bc84a287dc);
CAPNP_DECLARE_SCHEMA(e5223805a4f89b66);
CAPNP_DECLARE_SCHEMA(ca2c53a62aa79635);
CAPNP_DECLARE_SCHEMA(e63ecf2ed249ea72);
CAPNP_DECLARE_SCHEMA(b0574b7e87c89580);
CAPNP_DECLARE_SCHEMA(f4c7c9090f7f65ff);
CAPNP_DECLARE_SCHEMA(fadf6fefcc8670a1);
CAPNP_DECLARE_SCHEMA(838f7452c487badf);
CAPNP_DECLARE_SCHEMA(f171f28f75e452e6);
CAPNP_DECLARE_SCHEMA(cfa270b7ddc80a04);
CAPNP_DECLARE_SCHEMA(b56a367f43dc01de);
CAPNP_DECLARE_SCHEMA(ff343c185370b513);
CAPNP_DECLARE_SCHEMA(bcba8efb52090304);

}  // namespace schemas
}  // namespace capnp


struct UhdmRoot {
  UhdmRoot() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b2bce98887da19bc, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Process {
  Process() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c4de5d61fdda1fc2, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Scope {
  Scope() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(809d8aea310cd2d3, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Interface {
  Interface() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f204710c1a739934, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Interfacearray {
  Interfacearray() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a0c61698af16b048, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Contassign {
  Contassign() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9227d3f15c9cc33f, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Port {
  Port() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f71f31bc84a287dc, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Modulearray {
  Modulearray() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e5223805a4f89b66, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Primitive {
  Primitive() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ca2c53a62aa79635, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Primitivearray {
  Primitivearray() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e63ecf2ed249ea72, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Modpath {
  Modpath() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b0574b7e87c89580, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Tchk {
  Tchk() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f4c7c9090f7f65ff, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Defparam {
  Defparam() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fadf6fefcc8670a1, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Iodecl {
  Iodecl() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(838f7452c487badf, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Aliasstmt {
  Aliasstmt() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f171f28f75e452e6, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Clockingblock {
  Clockingblock() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cfa270b7ddc80a04, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Instancearray {
  Instancearray() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b56a367f43dc01de, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Module {
  Module() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff343c185370b513, 2, 20)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Design {
  Design() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bcba8efb52090304, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class UhdmRoot::Reader {
public:
  typedef UhdmRoot Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasDesigns() const;
  inline  ::capnp::List< ::Design>::Reader getDesigns() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UhdmRoot::Builder {
public:
  typedef UhdmRoot Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasDesigns();
  inline  ::capnp::List< ::Design>::Builder getDesigns();
  inline void setDesigns( ::capnp::List< ::Design>::Reader value);
  inline  ::capnp::List< ::Design>::Builder initDesigns(unsigned int size);
  inline void adoptDesigns(::capnp::Orphan< ::capnp::List< ::Design>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Design>> disownDesigns();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UhdmRoot::Pipeline {
public:
  typedef UhdmRoot Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Process::Reader {
public:
  typedef Process Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Process::Builder {
public:
  typedef Process Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Process::Pipeline {
public:
  typedef Process Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Scope::Reader {
public:
  typedef Scope Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Scope::Builder {
public:
  typedef Scope Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Scope::Pipeline {
public:
  typedef Scope Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Interface::Reader {
public:
  typedef Interface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Interface::Builder {
public:
  typedef Interface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Interface::Pipeline {
public:
  typedef Interface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Interfacearray::Reader {
public:
  typedef Interfacearray Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Interfacearray::Builder {
public:
  typedef Interfacearray Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Interfacearray::Pipeline {
public:
  typedef Interfacearray Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Contassign::Reader {
public:
  typedef Contassign Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Contassign::Builder {
public:
  typedef Contassign Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Contassign::Pipeline {
public:
  typedef Contassign Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Port::Reader {
public:
  typedef Port Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Port::Builder {
public:
  typedef Port Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Port::Pipeline {
public:
  typedef Port Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Modulearray::Reader {
public:
  typedef Modulearray Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Modulearray::Builder {
public:
  typedef Modulearray Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Modulearray::Pipeline {
public:
  typedef Modulearray Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Primitive::Reader {
public:
  typedef Primitive Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Primitive::Builder {
public:
  typedef Primitive Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Primitive::Pipeline {
public:
  typedef Primitive Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Primitivearray::Reader {
public:
  typedef Primitivearray Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Primitivearray::Builder {
public:
  typedef Primitivearray Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Primitivearray::Pipeline {
public:
  typedef Primitivearray Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Modpath::Reader {
public:
  typedef Modpath Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Modpath::Builder {
public:
  typedef Modpath Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Modpath::Pipeline {
public:
  typedef Modpath Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Tchk::Reader {
public:
  typedef Tchk Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Tchk::Builder {
public:
  typedef Tchk Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Tchk::Pipeline {
public:
  typedef Tchk Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Defparam::Reader {
public:
  typedef Defparam Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Defparam::Builder {
public:
  typedef Defparam Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Defparam::Pipeline {
public:
  typedef Defparam Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Iodecl::Reader {
public:
  typedef Iodecl Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Iodecl::Builder {
public:
  typedef Iodecl Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Iodecl::Pipeline {
public:
  typedef Iodecl Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Aliasstmt::Reader {
public:
  typedef Aliasstmt Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Aliasstmt::Builder {
public:
  typedef Aliasstmt Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Aliasstmt::Pipeline {
public:
  typedef Aliasstmt Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Clockingblock::Reader {
public:
  typedef Clockingblock Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Clockingblock::Builder {
public:
  typedef Clockingblock Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Clockingblock::Pipeline {
public:
  typedef Clockingblock Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Instancearray::Reader {
public:
  typedef Instancearray Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Instancearray::Builder {
public:
  typedef Instancearray Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Instancearray::Pipeline {
public:
  typedef Instancearray Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Module::Reader {
public:
  typedef Module Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

  inline bool hasVpiName() const;
  inline  ::capnp::Text::Reader getVpiName() const;

  inline bool getVpiTopModule() const;

  inline  ::int32_t getVpiDefDecayTime() const;

  inline bool hasInstancearray() const;
  inline  ::Instancearray::Reader getInstancearray() const;

  inline bool hasScope() const;
  inline  ::capnp::List< ::Scope>::Reader getScope() const;

  inline bool hasProcess() const;
  inline  ::capnp::List< ::Process>::Reader getProcess() const;

  inline bool hasPrimitive() const;
  inline  ::capnp::List< ::Primitive>::Reader getPrimitive() const;

  inline bool hasPrimitivearray() const;
  inline  ::capnp::List< ::Primitivearray>::Reader getPrimitivearray() const;

  inline bool hasGlobalclocking() const;
  inline  ::Clockingblock::Reader getGlobalclocking() const;

  inline bool hasDefaultclocking() const;
  inline  ::Clockingblock::Reader getDefaultclocking() const;

  inline bool hasPorts() const;
  inline  ::capnp::List< ::Port>::Reader getPorts() const;

  inline bool hasInterfaces() const;
  inline  ::capnp::List< ::Interface>::Reader getInterfaces() const;

  inline bool hasInterfacearrays() const;
  inline  ::capnp::List< ::Interfacearray>::Reader getInterfacearrays() const;

  inline bool hasContassigns() const;
  inline  ::capnp::List< ::Contassign>::Reader getContassigns() const;

  inline bool hasModules() const;
  inline  ::capnp::List< ::Module>::Reader getModules() const;

  inline bool hasModulearray() const;
  inline  ::capnp::List< ::Modulearray>::Reader getModulearray() const;

  inline bool hasModpath() const;
  inline  ::capnp::List< ::Modpath>::Reader getModpath() const;

  inline bool hasTchk() const;
  inline  ::capnp::List< ::Tchk>::Reader getTchk() const;

  inline bool hasDefparam() const;
  inline  ::capnp::List< ::Defparam>::Reader getDefparam() const;

  inline bool hasIodecl() const;
  inline  ::capnp::List< ::Iodecl>::Reader getIodecl() const;

  inline bool hasAliasstmt() const;
  inline  ::capnp::List< ::Aliasstmt>::Reader getAliasstmt() const;

  inline bool hasClockingblock() const;
  inline  ::capnp::List< ::Clockingblock>::Reader getClockingblock() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Module::Builder {
public:
  typedef Module Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

  inline bool hasVpiName();
  inline  ::capnp::Text::Builder getVpiName();
  inline void setVpiName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initVpiName(unsigned int size);
  inline void adoptVpiName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownVpiName();

  inline bool getVpiTopModule();
  inline void setVpiTopModule(bool value);

  inline  ::int32_t getVpiDefDecayTime();
  inline void setVpiDefDecayTime( ::int32_t value);

  inline bool hasInstancearray();
  inline  ::Instancearray::Builder getInstancearray();
  inline void setInstancearray( ::Instancearray::Reader value);
  inline  ::Instancearray::Builder initInstancearray();
  inline void adoptInstancearray(::capnp::Orphan< ::Instancearray>&& value);
  inline ::capnp::Orphan< ::Instancearray> disownInstancearray();

  inline bool hasScope();
  inline  ::capnp::List< ::Scope>::Builder getScope();
  inline void setScope( ::capnp::List< ::Scope>::Reader value);
  inline  ::capnp::List< ::Scope>::Builder initScope(unsigned int size);
  inline void adoptScope(::capnp::Orphan< ::capnp::List< ::Scope>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Scope>> disownScope();

  inline bool hasProcess();
  inline  ::capnp::List< ::Process>::Builder getProcess();
  inline void setProcess( ::capnp::List< ::Process>::Reader value);
  inline  ::capnp::List< ::Process>::Builder initProcess(unsigned int size);
  inline void adoptProcess(::capnp::Orphan< ::capnp::List< ::Process>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Process>> disownProcess();

  inline bool hasPrimitive();
  inline  ::capnp::List< ::Primitive>::Builder getPrimitive();
  inline void setPrimitive( ::capnp::List< ::Primitive>::Reader value);
  inline  ::capnp::List< ::Primitive>::Builder initPrimitive(unsigned int size);
  inline void adoptPrimitive(::capnp::Orphan< ::capnp::List< ::Primitive>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Primitive>> disownPrimitive();

  inline bool hasPrimitivearray();
  inline  ::capnp::List< ::Primitivearray>::Builder getPrimitivearray();
  inline void setPrimitivearray( ::capnp::List< ::Primitivearray>::Reader value);
  inline  ::capnp::List< ::Primitivearray>::Builder initPrimitivearray(unsigned int size);
  inline void adoptPrimitivearray(::capnp::Orphan< ::capnp::List< ::Primitivearray>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Primitivearray>> disownPrimitivearray();

  inline bool hasGlobalclocking();
  inline  ::Clockingblock::Builder getGlobalclocking();
  inline void setGlobalclocking( ::Clockingblock::Reader value);
  inline  ::Clockingblock::Builder initGlobalclocking();
  inline void adoptGlobalclocking(::capnp::Orphan< ::Clockingblock>&& value);
  inline ::capnp::Orphan< ::Clockingblock> disownGlobalclocking();

  inline bool hasDefaultclocking();
  inline  ::Clockingblock::Builder getDefaultclocking();
  inline void setDefaultclocking( ::Clockingblock::Reader value);
  inline  ::Clockingblock::Builder initDefaultclocking();
  inline void adoptDefaultclocking(::capnp::Orphan< ::Clockingblock>&& value);
  inline ::capnp::Orphan< ::Clockingblock> disownDefaultclocking();

  inline bool hasPorts();
  inline  ::capnp::List< ::Port>::Builder getPorts();
  inline void setPorts( ::capnp::List< ::Port>::Reader value);
  inline  ::capnp::List< ::Port>::Builder initPorts(unsigned int size);
  inline void adoptPorts(::capnp::Orphan< ::capnp::List< ::Port>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Port>> disownPorts();

  inline bool hasInterfaces();
  inline  ::capnp::List< ::Interface>::Builder getInterfaces();
  inline void setInterfaces( ::capnp::List< ::Interface>::Reader value);
  inline  ::capnp::List< ::Interface>::Builder initInterfaces(unsigned int size);
  inline void adoptInterfaces(::capnp::Orphan< ::capnp::List< ::Interface>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Interface>> disownInterfaces();

  inline bool hasInterfacearrays();
  inline  ::capnp::List< ::Interfacearray>::Builder getInterfacearrays();
  inline void setInterfacearrays( ::capnp::List< ::Interfacearray>::Reader value);
  inline  ::capnp::List< ::Interfacearray>::Builder initInterfacearrays(unsigned int size);
  inline void adoptInterfacearrays(::capnp::Orphan< ::capnp::List< ::Interfacearray>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Interfacearray>> disownInterfacearrays();

  inline bool hasContassigns();
  inline  ::capnp::List< ::Contassign>::Builder getContassigns();
  inline void setContassigns( ::capnp::List< ::Contassign>::Reader value);
  inline  ::capnp::List< ::Contassign>::Builder initContassigns(unsigned int size);
  inline void adoptContassigns(::capnp::Orphan< ::capnp::List< ::Contassign>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Contassign>> disownContassigns();

  inline bool hasModules();
  inline  ::capnp::List< ::Module>::Builder getModules();
  inline void setModules( ::capnp::List< ::Module>::Reader value);
  inline  ::capnp::List< ::Module>::Builder initModules(unsigned int size);
  inline void adoptModules(::capnp::Orphan< ::capnp::List< ::Module>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Module>> disownModules();

  inline bool hasModulearray();
  inline  ::capnp::List< ::Modulearray>::Builder getModulearray();
  inline void setModulearray( ::capnp::List< ::Modulearray>::Reader value);
  inline  ::capnp::List< ::Modulearray>::Builder initModulearray(unsigned int size);
  inline void adoptModulearray(::capnp::Orphan< ::capnp::List< ::Modulearray>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Modulearray>> disownModulearray();

  inline bool hasModpath();
  inline  ::capnp::List< ::Modpath>::Builder getModpath();
  inline void setModpath( ::capnp::List< ::Modpath>::Reader value);
  inline  ::capnp::List< ::Modpath>::Builder initModpath(unsigned int size);
  inline void adoptModpath(::capnp::Orphan< ::capnp::List< ::Modpath>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Modpath>> disownModpath();

  inline bool hasTchk();
  inline  ::capnp::List< ::Tchk>::Builder getTchk();
  inline void setTchk( ::capnp::List< ::Tchk>::Reader value);
  inline  ::capnp::List< ::Tchk>::Builder initTchk(unsigned int size);
  inline void adoptTchk(::capnp::Orphan< ::capnp::List< ::Tchk>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Tchk>> disownTchk();

  inline bool hasDefparam();
  inline  ::capnp::List< ::Defparam>::Builder getDefparam();
  inline void setDefparam( ::capnp::List< ::Defparam>::Reader value);
  inline  ::capnp::List< ::Defparam>::Builder initDefparam(unsigned int size);
  inline void adoptDefparam(::capnp::Orphan< ::capnp::List< ::Defparam>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Defparam>> disownDefparam();

  inline bool hasIodecl();
  inline  ::capnp::List< ::Iodecl>::Builder getIodecl();
  inline void setIodecl( ::capnp::List< ::Iodecl>::Reader value);
  inline  ::capnp::List< ::Iodecl>::Builder initIodecl(unsigned int size);
  inline void adoptIodecl(::capnp::Orphan< ::capnp::List< ::Iodecl>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Iodecl>> disownIodecl();

  inline bool hasAliasstmt();
  inline  ::capnp::List< ::Aliasstmt>::Builder getAliasstmt();
  inline void setAliasstmt( ::capnp::List< ::Aliasstmt>::Reader value);
  inline  ::capnp::List< ::Aliasstmt>::Builder initAliasstmt(unsigned int size);
  inline void adoptAliasstmt(::capnp::Orphan< ::capnp::List< ::Aliasstmt>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Aliasstmt>> disownAliasstmt();

  inline bool hasClockingblock();
  inline  ::capnp::List< ::Clockingblock>::Builder getClockingblock();
  inline void setClockingblock( ::capnp::List< ::Clockingblock>::Reader value);
  inline  ::capnp::List< ::Clockingblock>::Builder initClockingblock(unsigned int size);
  inline void adoptClockingblock(::capnp::Orphan< ::capnp::List< ::Clockingblock>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Clockingblock>> disownClockingblock();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Module::Pipeline {
public:
  typedef Module Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Instancearray::Pipeline getInstancearray();
  inline  ::Clockingblock::Pipeline getGlobalclocking();
  inline  ::Clockingblock::Pipeline getDefaultclocking();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Design::Reader {
public:
  typedef Design Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent() const;

  inline  ::uint32_t getUhdmParentType() const;

  inline bool hasVpiName() const;
  inline  ::capnp::Text::Reader getVpiName() const;

  inline bool hasAllModules() const;
  inline  ::capnp::List< ::Module>::Reader getAllModules() const;

  inline bool hasTopModules() const;
  inline  ::capnp::List< ::Module>::Reader getTopModules() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Design::Builder {
public:
  typedef Design Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVpiParent();
  inline void setVpiParent( ::uint32_t value);

  inline  ::uint32_t getUhdmParentType();
  inline void setUhdmParentType( ::uint32_t value);

  inline bool hasVpiName();
  inline  ::capnp::Text::Builder getVpiName();
  inline void setVpiName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initVpiName(unsigned int size);
  inline void adoptVpiName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownVpiName();

  inline bool hasAllModules();
  inline  ::capnp::List< ::Module>::Builder getAllModules();
  inline void setAllModules( ::capnp::List< ::Module>::Reader value);
  inline  ::capnp::List< ::Module>::Builder initAllModules(unsigned int size);
  inline void adoptAllModules(::capnp::Orphan< ::capnp::List< ::Module>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Module>> disownAllModules();

  inline bool hasTopModules();
  inline  ::capnp::List< ::Module>::Builder getTopModules();
  inline void setTopModules( ::capnp::List< ::Module>::Reader value);
  inline  ::capnp::List< ::Module>::Builder initTopModules(unsigned int size);
  inline void adoptTopModules(::capnp::Orphan< ::capnp::List< ::Module>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Module>> disownTopModules();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Design::Pipeline {
public:
  typedef Design Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool UhdmRoot::Reader::hasDesigns() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool UhdmRoot::Builder::hasDesigns() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Design>::Reader UhdmRoot::Reader::getDesigns() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Design>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Design>::Builder UhdmRoot::Builder::getDesigns() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Design>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void UhdmRoot::Builder::setDesigns( ::capnp::List< ::Design>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Design>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Design>::Builder UhdmRoot::Builder::initDesigns(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Design>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void UhdmRoot::Builder::adoptDesigns(
    ::capnp::Orphan< ::capnp::List< ::Design>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Design>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Design>> UhdmRoot::Builder::disownDesigns() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Design>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::uint32_t Process::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Process::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Process::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Process::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Process::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Process::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Scope::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Scope::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Scope::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Scope::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Scope::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Scope::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Interface::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Interface::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Interface::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Interface::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Interface::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Interface::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Interfacearray::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Interfacearray::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Interfacearray::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Interfacearray::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Interfacearray::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Interfacearray::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Contassign::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Contassign::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Contassign::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Contassign::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Contassign::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Contassign::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Port::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Port::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Port::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Port::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Port::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Port::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Modulearray::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Modulearray::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Modulearray::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Modulearray::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Modulearray::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Modulearray::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Primitive::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Primitive::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Primitive::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Primitive::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Primitive::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Primitive::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Primitivearray::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Primitivearray::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Primitivearray::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Primitivearray::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Primitivearray::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Primitivearray::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Modpath::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Modpath::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Modpath::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Modpath::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Modpath::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Modpath::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Tchk::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Tchk::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Tchk::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Tchk::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Tchk::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Tchk::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Defparam::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Defparam::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Defparam::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Defparam::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Defparam::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Defparam::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Iodecl::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Iodecl::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Iodecl::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Iodecl::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Iodecl::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Iodecl::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Aliasstmt::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Aliasstmt::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Aliasstmt::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Aliasstmt::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Aliasstmt::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Aliasstmt::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Clockingblock::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Clockingblock::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Clockingblock::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Clockingblock::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Clockingblock::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Clockingblock::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Instancearray::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Instancearray::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Instancearray::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Instancearray::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Instancearray::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Instancearray::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Module::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Module::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Module::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Module::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Module::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Module::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline bool Module::Reader::hasVpiName() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasVpiName() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Module::Reader::getVpiName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Module::Builder::getVpiName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Module::Builder::setVpiName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Module::Builder::initVpiName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptVpiName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Module::Builder::disownVpiName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Module::Reader::getVpiTopModule() const {
  return _reader.getDataField<bool>(
      64 * ::capnp::ELEMENTS);
}

inline bool Module::Builder::getVpiTopModule() {
  return _builder.getDataField<bool>(
      64 * ::capnp::ELEMENTS);
}
inline void Module::Builder::setVpiTopModule(bool value) {
  _builder.setDataField<bool>(
      64 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Module::Reader::getVpiDefDecayTime() const {
  return _reader.getDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS);
}

inline  ::int32_t Module::Builder::getVpiDefDecayTime() {
  return _builder.getDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS);
}
inline void Module::Builder::setVpiDefDecayTime( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS, value);
}

inline bool Module::Reader::hasInstancearray() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasInstancearray() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::Instancearray::Reader Module::Reader::getInstancearray() const {
  return ::capnp::_::PointerHelpers< ::Instancearray>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::Instancearray::Builder Module::Builder::getInstancearray() {
  return ::capnp::_::PointerHelpers< ::Instancearray>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Instancearray::Pipeline Module::Pipeline::getInstancearray() {
  return  ::Instancearray::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Module::Builder::setInstancearray( ::Instancearray::Reader value) {
  ::capnp::_::PointerHelpers< ::Instancearray>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::Instancearray::Builder Module::Builder::initInstancearray() {
  return ::capnp::_::PointerHelpers< ::Instancearray>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Module::Builder::adoptInstancearray(
    ::capnp::Orphan< ::Instancearray>&& value) {
  ::capnp::_::PointerHelpers< ::Instancearray>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Instancearray> Module::Builder::disownInstancearray() {
  return ::capnp::_::PointerHelpers< ::Instancearray>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasScope() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasScope() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Scope>::Reader Module::Reader::getScope() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Scope>>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Scope>::Builder Module::Builder::getScope() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Scope>>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void Module::Builder::setScope( ::capnp::List< ::Scope>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Scope>>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Scope>::Builder Module::Builder::initScope(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Scope>>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptScope(
    ::capnp::Orphan< ::capnp::List< ::Scope>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Scope>>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Scope>> Module::Builder::disownScope() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Scope>>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasProcess() const {
  return !_reader.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasProcess() {
  return !_builder.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Process>::Reader Module::Reader::getProcess() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Process>>::get(
      _reader.getPointerField(3 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Process>::Builder Module::Builder::getProcess() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Process>>::get(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
inline void Module::Builder::setProcess( ::capnp::List< ::Process>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Process>>::set(
      _builder.getPointerField(3 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Process>::Builder Module::Builder::initProcess(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Process>>::init(
      _builder.getPointerField(3 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptProcess(
    ::capnp::Orphan< ::capnp::List< ::Process>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Process>>::adopt(
      _builder.getPointerField(3 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Process>> Module::Builder::disownProcess() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Process>>::disown(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasPrimitive() const {
  return !_reader.getPointerField(4 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasPrimitive() {
  return !_builder.getPointerField(4 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Primitive>::Reader Module::Reader::getPrimitive() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Primitive>>::get(
      _reader.getPointerField(4 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Primitive>::Builder Module::Builder::getPrimitive() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Primitive>>::get(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}
inline void Module::Builder::setPrimitive( ::capnp::List< ::Primitive>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Primitive>>::set(
      _builder.getPointerField(4 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Primitive>::Builder Module::Builder::initPrimitive(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Primitive>>::init(
      _builder.getPointerField(4 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptPrimitive(
    ::capnp::Orphan< ::capnp::List< ::Primitive>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Primitive>>::adopt(
      _builder.getPointerField(4 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Primitive>> Module::Builder::disownPrimitive() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Primitive>>::disown(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasPrimitivearray() const {
  return !_reader.getPointerField(5 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasPrimitivearray() {
  return !_builder.getPointerField(5 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Primitivearray>::Reader Module::Reader::getPrimitivearray() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Primitivearray>>::get(
      _reader.getPointerField(5 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Primitivearray>::Builder Module::Builder::getPrimitivearray() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Primitivearray>>::get(
      _builder.getPointerField(5 * ::capnp::POINTERS));
}
inline void Module::Builder::setPrimitivearray( ::capnp::List< ::Primitivearray>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Primitivearray>>::set(
      _builder.getPointerField(5 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Primitivearray>::Builder Module::Builder::initPrimitivearray(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Primitivearray>>::init(
      _builder.getPointerField(5 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptPrimitivearray(
    ::capnp::Orphan< ::capnp::List< ::Primitivearray>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Primitivearray>>::adopt(
      _builder.getPointerField(5 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Primitivearray>> Module::Builder::disownPrimitivearray() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Primitivearray>>::disown(
      _builder.getPointerField(5 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasGlobalclocking() const {
  return !_reader.getPointerField(6 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasGlobalclocking() {
  return !_builder.getPointerField(6 * ::capnp::POINTERS).isNull();
}
inline  ::Clockingblock::Reader Module::Reader::getGlobalclocking() const {
  return ::capnp::_::PointerHelpers< ::Clockingblock>::get(
      _reader.getPointerField(6 * ::capnp::POINTERS));
}
inline  ::Clockingblock::Builder Module::Builder::getGlobalclocking() {
  return ::capnp::_::PointerHelpers< ::Clockingblock>::get(
      _builder.getPointerField(6 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Clockingblock::Pipeline Module::Pipeline::getGlobalclocking() {
  return  ::Clockingblock::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void Module::Builder::setGlobalclocking( ::Clockingblock::Reader value) {
  ::capnp::_::PointerHelpers< ::Clockingblock>::set(
      _builder.getPointerField(6 * ::capnp::POINTERS), value);
}
inline  ::Clockingblock::Builder Module::Builder::initGlobalclocking() {
  return ::capnp::_::PointerHelpers< ::Clockingblock>::init(
      _builder.getPointerField(6 * ::capnp::POINTERS));
}
inline void Module::Builder::adoptGlobalclocking(
    ::capnp::Orphan< ::Clockingblock>&& value) {
  ::capnp::_::PointerHelpers< ::Clockingblock>::adopt(
      _builder.getPointerField(6 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Clockingblock> Module::Builder::disownGlobalclocking() {
  return ::capnp::_::PointerHelpers< ::Clockingblock>::disown(
      _builder.getPointerField(6 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasDefaultclocking() const {
  return !_reader.getPointerField(7 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasDefaultclocking() {
  return !_builder.getPointerField(7 * ::capnp::POINTERS).isNull();
}
inline  ::Clockingblock::Reader Module::Reader::getDefaultclocking() const {
  return ::capnp::_::PointerHelpers< ::Clockingblock>::get(
      _reader.getPointerField(7 * ::capnp::POINTERS));
}
inline  ::Clockingblock::Builder Module::Builder::getDefaultclocking() {
  return ::capnp::_::PointerHelpers< ::Clockingblock>::get(
      _builder.getPointerField(7 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Clockingblock::Pipeline Module::Pipeline::getDefaultclocking() {
  return  ::Clockingblock::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void Module::Builder::setDefaultclocking( ::Clockingblock::Reader value) {
  ::capnp::_::PointerHelpers< ::Clockingblock>::set(
      _builder.getPointerField(7 * ::capnp::POINTERS), value);
}
inline  ::Clockingblock::Builder Module::Builder::initDefaultclocking() {
  return ::capnp::_::PointerHelpers< ::Clockingblock>::init(
      _builder.getPointerField(7 * ::capnp::POINTERS));
}
inline void Module::Builder::adoptDefaultclocking(
    ::capnp::Orphan< ::Clockingblock>&& value) {
  ::capnp::_::PointerHelpers< ::Clockingblock>::adopt(
      _builder.getPointerField(7 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Clockingblock> Module::Builder::disownDefaultclocking() {
  return ::capnp::_::PointerHelpers< ::Clockingblock>::disown(
      _builder.getPointerField(7 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasPorts() const {
  return !_reader.getPointerField(8 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasPorts() {
  return !_builder.getPointerField(8 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Port>::Reader Module::Reader::getPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Port>>::get(
      _reader.getPointerField(8 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Port>::Builder Module::Builder::getPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Port>>::get(
      _builder.getPointerField(8 * ::capnp::POINTERS));
}
inline void Module::Builder::setPorts( ::capnp::List< ::Port>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Port>>::set(
      _builder.getPointerField(8 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Port>::Builder Module::Builder::initPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Port>>::init(
      _builder.getPointerField(8 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptPorts(
    ::capnp::Orphan< ::capnp::List< ::Port>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Port>>::adopt(
      _builder.getPointerField(8 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Port>> Module::Builder::disownPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Port>>::disown(
      _builder.getPointerField(8 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasInterfaces() const {
  return !_reader.getPointerField(9 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasInterfaces() {
  return !_builder.getPointerField(9 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Interface>::Reader Module::Reader::getInterfaces() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Interface>>::get(
      _reader.getPointerField(9 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Interface>::Builder Module::Builder::getInterfaces() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Interface>>::get(
      _builder.getPointerField(9 * ::capnp::POINTERS));
}
inline void Module::Builder::setInterfaces( ::capnp::List< ::Interface>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Interface>>::set(
      _builder.getPointerField(9 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Interface>::Builder Module::Builder::initInterfaces(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Interface>>::init(
      _builder.getPointerField(9 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptInterfaces(
    ::capnp::Orphan< ::capnp::List< ::Interface>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Interface>>::adopt(
      _builder.getPointerField(9 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Interface>> Module::Builder::disownInterfaces() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Interface>>::disown(
      _builder.getPointerField(9 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasInterfacearrays() const {
  return !_reader.getPointerField(10 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasInterfacearrays() {
  return !_builder.getPointerField(10 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Interfacearray>::Reader Module::Reader::getInterfacearrays() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Interfacearray>>::get(
      _reader.getPointerField(10 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Interfacearray>::Builder Module::Builder::getInterfacearrays() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Interfacearray>>::get(
      _builder.getPointerField(10 * ::capnp::POINTERS));
}
inline void Module::Builder::setInterfacearrays( ::capnp::List< ::Interfacearray>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Interfacearray>>::set(
      _builder.getPointerField(10 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Interfacearray>::Builder Module::Builder::initInterfacearrays(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Interfacearray>>::init(
      _builder.getPointerField(10 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptInterfacearrays(
    ::capnp::Orphan< ::capnp::List< ::Interfacearray>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Interfacearray>>::adopt(
      _builder.getPointerField(10 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Interfacearray>> Module::Builder::disownInterfacearrays() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Interfacearray>>::disown(
      _builder.getPointerField(10 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasContassigns() const {
  return !_reader.getPointerField(11 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasContassigns() {
  return !_builder.getPointerField(11 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Contassign>::Reader Module::Reader::getContassigns() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Contassign>>::get(
      _reader.getPointerField(11 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Contassign>::Builder Module::Builder::getContassigns() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Contassign>>::get(
      _builder.getPointerField(11 * ::capnp::POINTERS));
}
inline void Module::Builder::setContassigns( ::capnp::List< ::Contassign>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Contassign>>::set(
      _builder.getPointerField(11 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Contassign>::Builder Module::Builder::initContassigns(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Contassign>>::init(
      _builder.getPointerField(11 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptContassigns(
    ::capnp::Orphan< ::capnp::List< ::Contassign>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Contassign>>::adopt(
      _builder.getPointerField(11 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Contassign>> Module::Builder::disownContassigns() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Contassign>>::disown(
      _builder.getPointerField(11 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasModules() const {
  return !_reader.getPointerField(12 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasModules() {
  return !_builder.getPointerField(12 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Module>::Reader Module::Reader::getModules() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::get(
      _reader.getPointerField(12 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Module>::Builder Module::Builder::getModules() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::get(
      _builder.getPointerField(12 * ::capnp::POINTERS));
}
inline void Module::Builder::setModules( ::capnp::List< ::Module>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::set(
      _builder.getPointerField(12 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Module>::Builder Module::Builder::initModules(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::init(
      _builder.getPointerField(12 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptModules(
    ::capnp::Orphan< ::capnp::List< ::Module>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::adopt(
      _builder.getPointerField(12 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Module>> Module::Builder::disownModules() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::disown(
      _builder.getPointerField(12 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasModulearray() const {
  return !_reader.getPointerField(13 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasModulearray() {
  return !_builder.getPointerField(13 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Modulearray>::Reader Module::Reader::getModulearray() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Modulearray>>::get(
      _reader.getPointerField(13 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Modulearray>::Builder Module::Builder::getModulearray() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Modulearray>>::get(
      _builder.getPointerField(13 * ::capnp::POINTERS));
}
inline void Module::Builder::setModulearray( ::capnp::List< ::Modulearray>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Modulearray>>::set(
      _builder.getPointerField(13 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Modulearray>::Builder Module::Builder::initModulearray(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Modulearray>>::init(
      _builder.getPointerField(13 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptModulearray(
    ::capnp::Orphan< ::capnp::List< ::Modulearray>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Modulearray>>::adopt(
      _builder.getPointerField(13 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Modulearray>> Module::Builder::disownModulearray() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Modulearray>>::disown(
      _builder.getPointerField(13 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasModpath() const {
  return !_reader.getPointerField(14 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasModpath() {
  return !_builder.getPointerField(14 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Modpath>::Reader Module::Reader::getModpath() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Modpath>>::get(
      _reader.getPointerField(14 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Modpath>::Builder Module::Builder::getModpath() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Modpath>>::get(
      _builder.getPointerField(14 * ::capnp::POINTERS));
}
inline void Module::Builder::setModpath( ::capnp::List< ::Modpath>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Modpath>>::set(
      _builder.getPointerField(14 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Modpath>::Builder Module::Builder::initModpath(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Modpath>>::init(
      _builder.getPointerField(14 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptModpath(
    ::capnp::Orphan< ::capnp::List< ::Modpath>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Modpath>>::adopt(
      _builder.getPointerField(14 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Modpath>> Module::Builder::disownModpath() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Modpath>>::disown(
      _builder.getPointerField(14 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasTchk() const {
  return !_reader.getPointerField(15 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasTchk() {
  return !_builder.getPointerField(15 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Tchk>::Reader Module::Reader::getTchk() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Tchk>>::get(
      _reader.getPointerField(15 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Tchk>::Builder Module::Builder::getTchk() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Tchk>>::get(
      _builder.getPointerField(15 * ::capnp::POINTERS));
}
inline void Module::Builder::setTchk( ::capnp::List< ::Tchk>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Tchk>>::set(
      _builder.getPointerField(15 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Tchk>::Builder Module::Builder::initTchk(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Tchk>>::init(
      _builder.getPointerField(15 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptTchk(
    ::capnp::Orphan< ::capnp::List< ::Tchk>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Tchk>>::adopt(
      _builder.getPointerField(15 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Tchk>> Module::Builder::disownTchk() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Tchk>>::disown(
      _builder.getPointerField(15 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasDefparam() const {
  return !_reader.getPointerField(16 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasDefparam() {
  return !_builder.getPointerField(16 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Defparam>::Reader Module::Reader::getDefparam() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Defparam>>::get(
      _reader.getPointerField(16 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Defparam>::Builder Module::Builder::getDefparam() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Defparam>>::get(
      _builder.getPointerField(16 * ::capnp::POINTERS));
}
inline void Module::Builder::setDefparam( ::capnp::List< ::Defparam>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Defparam>>::set(
      _builder.getPointerField(16 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Defparam>::Builder Module::Builder::initDefparam(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Defparam>>::init(
      _builder.getPointerField(16 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptDefparam(
    ::capnp::Orphan< ::capnp::List< ::Defparam>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Defparam>>::adopt(
      _builder.getPointerField(16 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Defparam>> Module::Builder::disownDefparam() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Defparam>>::disown(
      _builder.getPointerField(16 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasIodecl() const {
  return !_reader.getPointerField(17 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasIodecl() {
  return !_builder.getPointerField(17 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Iodecl>::Reader Module::Reader::getIodecl() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Iodecl>>::get(
      _reader.getPointerField(17 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Iodecl>::Builder Module::Builder::getIodecl() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Iodecl>>::get(
      _builder.getPointerField(17 * ::capnp::POINTERS));
}
inline void Module::Builder::setIodecl( ::capnp::List< ::Iodecl>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Iodecl>>::set(
      _builder.getPointerField(17 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Iodecl>::Builder Module::Builder::initIodecl(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Iodecl>>::init(
      _builder.getPointerField(17 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptIodecl(
    ::capnp::Orphan< ::capnp::List< ::Iodecl>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Iodecl>>::adopt(
      _builder.getPointerField(17 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Iodecl>> Module::Builder::disownIodecl() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Iodecl>>::disown(
      _builder.getPointerField(17 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasAliasstmt() const {
  return !_reader.getPointerField(18 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasAliasstmt() {
  return !_builder.getPointerField(18 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Aliasstmt>::Reader Module::Reader::getAliasstmt() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Aliasstmt>>::get(
      _reader.getPointerField(18 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Aliasstmt>::Builder Module::Builder::getAliasstmt() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Aliasstmt>>::get(
      _builder.getPointerField(18 * ::capnp::POINTERS));
}
inline void Module::Builder::setAliasstmt( ::capnp::List< ::Aliasstmt>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Aliasstmt>>::set(
      _builder.getPointerField(18 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Aliasstmt>::Builder Module::Builder::initAliasstmt(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Aliasstmt>>::init(
      _builder.getPointerField(18 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptAliasstmt(
    ::capnp::Orphan< ::capnp::List< ::Aliasstmt>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Aliasstmt>>::adopt(
      _builder.getPointerField(18 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Aliasstmt>> Module::Builder::disownAliasstmt() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Aliasstmt>>::disown(
      _builder.getPointerField(18 * ::capnp::POINTERS));
}

inline bool Module::Reader::hasClockingblock() const {
  return !_reader.getPointerField(19 * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasClockingblock() {
  return !_builder.getPointerField(19 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Clockingblock>::Reader Module::Reader::getClockingblock() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Clockingblock>>::get(
      _reader.getPointerField(19 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Clockingblock>::Builder Module::Builder::getClockingblock() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Clockingblock>>::get(
      _builder.getPointerField(19 * ::capnp::POINTERS));
}
inline void Module::Builder::setClockingblock( ::capnp::List< ::Clockingblock>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Clockingblock>>::set(
      _builder.getPointerField(19 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Clockingblock>::Builder Module::Builder::initClockingblock(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Clockingblock>>::init(
      _builder.getPointerField(19 * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptClockingblock(
    ::capnp::Orphan< ::capnp::List< ::Clockingblock>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Clockingblock>>::adopt(
      _builder.getPointerField(19 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Clockingblock>> Module::Builder::disownClockingblock() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Clockingblock>>::disown(
      _builder.getPointerField(19 * ::capnp::POINTERS));
}

inline  ::uint32_t Design::Reader::getVpiParent() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Design::Builder::getVpiParent() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Design::Builder::setVpiParent( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Design::Reader::getUhdmParentType() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Design::Builder::getUhdmParentType() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Design::Builder::setUhdmParentType( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline bool Design::Reader::hasVpiName() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Design::Builder::hasVpiName() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Design::Reader::getVpiName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Design::Builder::getVpiName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Design::Builder::setVpiName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Design::Builder::initVpiName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Design::Builder::adoptVpiName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Design::Builder::disownVpiName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Design::Reader::hasAllModules() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Design::Builder::hasAllModules() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Module>::Reader Design::Reader::getAllModules() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Module>::Builder Design::Builder::getAllModules() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Design::Builder::setAllModules( ::capnp::List< ::Module>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Module>::Builder Design::Builder::initAllModules(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void Design::Builder::adoptAllModules(
    ::capnp::Orphan< ::capnp::List< ::Module>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Module>> Design::Builder::disownAllModules() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool Design::Reader::hasTopModules() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool Design::Builder::hasTopModules() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Module>::Reader Design::Reader::getTopModules() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Module>::Builder Design::Builder::getTopModules() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void Design::Builder::setTopModules( ::capnp::List< ::Module>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Module>::Builder Design::Builder::initTopModules(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void Design::Builder::adoptTopModules(
    ::capnp::Orphan< ::capnp::List< ::Module>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Module>> Design::Builder::disownTopModules() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Module>>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}


#endif  // CAPNP_INCLUDED_fff7299129556877_
