/*
 Do not modify, auto-generated by model_gen.tcl

 Copyright 2019 Alain Dargelas

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 * File:   vpi_user.cpp
 * Author:
 *
 * Created on December 14, 2019, 10:03 PM
 */
#include <string>
#include <vector>
#include <iostream>
#include "include/vpi_user.h"
#include "include/vpi_uhdm.h"
#include "headers/containers.h"
#include "headers/uhdm.h"
#include <string.h>

#include "headers/scope.h"
#include "headers/port.h"
#include "headers/interface.h"
#include "headers/interface_array.h"
#include "headers/cont_assign.h"
#include "headers/process.h"
#include "headers/module.h"
#include "headers/design.h"


using namespace UHDM;

vpiHandle vpi_handle_by_name (PLI_BYTE8    *name,
                              vpiHandle    scope) {
  return 0;
}

vpiHandle vpi_handle_by_index (vpiHandle object,
                                PLI_INT32    indx) {
  return 0;
}

/* for traversing relationships */

vpiHandle vpi_handle (PLI_INT32 type,
                      vpiHandle   refHandle) {
  //uhdm_handle* handle = (uhdm_handle*) refHandle;
  //BaseClass*  object = (BaseClass*) handle->object;
  
  return 0;
}

vpiHandle vpi_handle_multi (PLI_INT32 type,
                            vpiHandle   refHandle1,
                            vpiHandle   refHandle2,
                            ... ) {
  return 0;
}

vpiHandle vpi_iterate (PLI_INT32 type, vpiHandle refHandle) {
  const uhdm_handle* const handle = (uhdm_handle*) refHandle;
  const BaseClass*  object = (BaseClass*) handle->object;
  
    
 if (handle->type == uhdmmodule) {
 if (type == vpiPort) {
 if (((module*)(object))->get_ports())
 return (vpiHandle) new uhdm_handle(uhdmports, ((module*)(object))->get_ports());
 else return 0;
  }
 }

    
 if (handle->type == uhdmmodule) {
 if (type == uhdminterface) {
 if (((module*)(object))->get_interfaces())
 return (vpiHandle) new uhdm_handle(uhdminterfaces, ((module*)(object))->get_interfaces());
 else return 0;
  }
 }

    
 if (handle->type == uhdmmodule) {
 if (type == uhdminterface_array) {
 if (((module*)(object))->get_interface_arrays())
 return (vpiHandle) new uhdm_handle(uhdminterface_arrays, ((module*)(object))->get_interface_arrays());
 else return 0;
  }
 }

    
 if (handle->type == uhdmmodule) {
 if (type == vpiContAssign) {
 if (((module*)(object))->get_cont_assigns())
 return (vpiHandle) new uhdm_handle(uhdmcont_assigns, ((module*)(object))->get_cont_assigns());
 else return 0;
  }
 }

    
 if (handle->type == uhdmmodule) {
 if (type == vpiModule) {
 if (((module*)(object))->get_modules())
 return (vpiHandle) new uhdm_handle(uhdmmodules, ((module*)(object))->get_modules());
 else return 0;
  }
 }

    
 if (handle->type == uhdmdesign) {
 if (type == uhdmallModules) {
 if (((design*)(object))->get_allModules())
 return (vpiHandle) new uhdm_handle(uhdmallModules, ((design*)(object))->get_allModules());
 else return 0;
  }
 }

    
 if (handle->type == uhdmdesign) {
 if (type == uhdmtopModules) {
 if (((design*)(object))->get_topModules())
 return (vpiHandle) new uhdm_handle(uhdmtopModules, ((design*)(object))->get_topModules());
 else return 0;
  }
 }

  std::cout << "Bad usage of vpi_iterate" << std::endl;    
  return 0;   
}

vpiHandle vpi_scan (vpiHandle iterator) {
  if (!iterator) return 0;
  uhdm_handle* handle = (uhdm_handle*) iterator;
  const void* vect = handle->object;
  

  if (handle->type == uhdmports) {
 VectorOfport* the_vec = (VectorOfport*)vect;
 if (handle->index < the_vec->size()) {
 uhdm_handle* h = new uhdm_handle(uhdmport, the_vec->at(handle->index));
 handle->index++;
 return (vpiHandle) h;
 }
 }

  if (handle->type == uhdminterfaces) {
 VectorOfinterface* the_vec = (VectorOfinterface*)vect;
 if (handle->index < the_vec->size()) {
 uhdm_handle* h = new uhdm_handle(uhdminterface, the_vec->at(handle->index));
 handle->index++;
 return (vpiHandle) h;
 }
 }

  if (handle->type == uhdminterface_arrays) {
 VectorOfinterface_array* the_vec = (VectorOfinterface_array*)vect;
 if (handle->index < the_vec->size()) {
 uhdm_handle* h = new uhdm_handle(uhdminterface_array, the_vec->at(handle->index));
 handle->index++;
 return (vpiHandle) h;
 }
 }

  if (handle->type == uhdmcont_assigns) {
 VectorOfcont_assign* the_vec = (VectorOfcont_assign*)vect;
 if (handle->index < the_vec->size()) {
 uhdm_handle* h = new uhdm_handle(uhdmcont_assign, the_vec->at(handle->index));
 handle->index++;
 return (vpiHandle) h;
 }
 }

  if (handle->type == uhdmmodules) {
 VectorOfmodule* the_vec = (VectorOfmodule*)vect;
 if (handle->index < the_vec->size()) {
 uhdm_handle* h = new uhdm_handle(uhdmmodule, the_vec->at(handle->index));
 handle->index++;
 return (vpiHandle) h;
 }
 }

  if (handle->type == uhdmallModules) {
 VectorOfmodule* the_vec = (VectorOfmodule*)vect;
 if (handle->index < the_vec->size()) {
 uhdm_handle* h = new uhdm_handle(uhdmmodule, the_vec->at(handle->index));
 handle->index++;
 return (vpiHandle) h;
 }
 }

  if (handle->type == uhdmtopModules) {
 VectorOfmodule* the_vec = (VectorOfmodule*)vect;
 if (handle->index < the_vec->size()) {
 uhdm_handle* h = new uhdm_handle(uhdmmodule, the_vec->at(handle->index));
 handle->index++;
 return (vpiHandle) h;
 }
 }
  return 0;
}

PLI_INT32 vpi_free_object (vpiHandle object) {
  return vpi_release_handle(object);
}

PLI_INT32 vpi_release_handle (vpiHandle object) {
  delete (uhdm_handle*) object;
  return 0;
}

/* for processing properties */

PLI_INT32 vpi_get (PLI_INT32   property,
                   vpiHandle   object) {
  uhdm_handle* handle = (uhdm_handle*) object;
  BaseClass*  obj = (BaseClass*) handle->object;
  
 if (handle->type == uhdmmodule) {
     if (property == vpiTopModule) {
       return ((module*)(obj))->get_vpiTopModule();
     } 
}

 if (handle->type == uhdmmodule) {
     if (property == vpiDefDecayTime) {
       return ((module*)(obj))->get_vpiDefDecayTime();
     } 
}

  return 0;
}

PLI_INT64 vpi_get64 (PLI_INT32 property,
                     vpiHandle   object) {
  uhdm_handle* handle = (uhdm_handle*) object;
  BaseClass*  obj = (BaseClass*) handle->object;
  
 if (handle->type == uhdmmodule) {
     if (property == vpiTopModule) {
       return ((module*)(obj))->get_vpiTopModule();
     } 
}

 if (handle->type == uhdmmodule) {
     if (property == vpiDefDecayTime) {
       return ((module*)(obj))->get_vpiDefDecayTime();
     } 
}

  return 0;
}

PLI_BYTE8 *vpi_get_str (PLI_INT32 property,
                        vpiHandle   object) {
   uhdm_handle* handle = (uhdm_handle*) object;
  BaseClass*  obj = (BaseClass*) handle->object;
  
 if (handle->type == uhdmmodule) {
     if (property == vpiName) {
       return (PLI_BYTE8*) strdup(((module*)(obj))->get_vpiName().c_str());
     } 
}

  return 0;
}


/* delay processing */

void vpi_get_delays (vpiHandle object,
                     p_vpi_delay delay_p) {
}

void vpi_put_delays (vpiHandle object,
                     p_vpi_delay delay_p) {
}

/* value processing */

void vpi_get_value (vpiHandle expr,
                    p_vpi_value value_p) {
}

vpiHandle vpi_put_value (vpiHandle object,
                         p_vpi_value value_p,
                         p_vpi_time time_p,
                         PLI_INT32 flags) {
  return 0;
}

void vpi_get_value_array (vpiHandle object,
                          p_vpi_arrayvalue arrayvalue_p,
                          PLI_INT32 *index_p,
                          PLI_UINT32 num) {
}

void vpi_put_value_array (vpiHandle object,
                          p_vpi_arrayvalue arrayvalue_p,
                          PLI_INT32 *index_p,
                          PLI_UINT32 num) {
}

/* time processing */

void vpi_get_time(vpiHandle object,
                  p_vpi_time time_p) {
}


PLI_INT32 vpi_get_data (PLI_INT32 id,
                        PLI_BYTE8 *dataLoc,
			PLI_INT32 numOfBytes) {
  return 0;
}

PLI_INT32 vpi_put_data (PLI_INT32 id,
                        PLI_BYTE8 *dataLoc,
			PLI_INT32 numOfBytes) {
  return 0;
}

void *vpi_get_userdata (vpiHandle obj) {
  return 0;
}

PLI_INT32 vpi_put_userdata (vpiHandle obj,
                            void *userdata) {
  return 0;
}

vpiHandle vpi_handle_by_multi_index (vpiHandle obj,
                                     PLI_INT32 num_index,
                                     PLI_INT32 *index_array) {
  return 0;
}

