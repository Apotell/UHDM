/*
 Do not modify, auto-generated by model_gen.tcl

 Copyright 2019 Alain Dargelas

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 * File:   ports.h
 * Author:
 *
 * Created on December 14, 2019, 10:03 PM
 */

#ifndef PORTS_H
#define PORTS_H

namespace UHDM {

  class ports : public BaseClass {
  public:
    // Implicit constructor used to initialize all members,
    // comment: ports();
    ~ports()  {}
    
    unsigned int get_vpiPortIndex() const { return vpiPortIndex_; }

    bool set_vpiPortIndex(unsigned int data) { vpiPortIndex_ = data; return true;}

    std::string get_vpiName() const { return SymbolFactory::getSymbol(vpiName_); }

    bool set_vpiName(std::string data) { vpiName_ = SymbolFactory::make(data); return true; }

    unsigned int get_vpiPortType() const { return vpiPortType_; }

    bool set_vpiPortType(unsigned int data) { vpiPortType_ = data; return true;}

    bool get_vpiScalar() const { return vpiScalar_; }

    bool set_vpiScalar(bool data) { vpiScalar_ = data; return true;}

    bool get_vpiVector() const { return vpiVector_; }

    bool set_vpiVector(bool data) { vpiVector_ = data; return true;}

    bool get_vpiConnByName() const { return vpiConnByName_; }

    bool set_vpiConnByName(bool data) { vpiConnByName_ = data; return true;}

    unsigned int get_vpiDirection() const { return vpiDirection_; }

    bool set_vpiDirection(unsigned int data) { vpiDirection_ = data; return true;}

    unsigned int get_vpiSize() const { return vpiSize_; }

    bool set_vpiSize(unsigned int data) { vpiSize_ = data; return true;}

    std::string get_vpiExplicitName() const { return SymbolFactory::getSymbol(vpiExplicitName_); }

    bool set_vpiExplicitName(std::string data) { vpiExplicitName_ = SymbolFactory::make(data); return true; }

    typespec* get_typespecs() const { return typespecs_; }

    bool set_typespecs(typespec* data) { typespecs_ = data; return true;}

    instance* get_instance() const { return instance_; }

    bool set_instance(instance* data) { instance_ = data; return true;}

    module* get_module() const { return module_; }

    bool set_module(module* data) { module_ = data; return true;}

    any* get_high_conn() const { return high_conn_; }

    bool set_high_conn(any* data) {if (!expr_ref_obj_groupGroupCompliant(data)) return false; high_conn_ = data; return true;}

    any* get_low_conn() const { return low_conn_; }

    bool set_low_conn(any* data) {if (!expr_ref_obj_groupGroupCompliant(data)) return false; low_conn_ = data; return true;}

    virtual unsigned int getUhdmType() { return uhdmports; }   
  private:
    
    unsigned int vpiPortIndex_;

    unsigned int vpiName_;

    unsigned int vpiPortType_;

    bool vpiScalar_;

    bool vpiVector_;

    bool vpiConnByName_;

    unsigned int vpiDirection_;

    unsigned int vpiSize_;

    unsigned int vpiExplicitName_;

    typespec* typespecs_;

    instance* instance_;

    module* module_;

    any* high_conn_;

    any* low_conn_;

  };

  class portsFactory {
  friend Serializer;
  public:
  static ports* make() {
    ports* obj = new ports();
    objects_.push_back(obj);
    return obj;
  }
  private:
    static std::vector<ports*> objects_;
  };
 	      
  class VectorOfportsFactory {
  friend Serializer;
  public:
  static std::vector<ports*>* make() {
    std::vector<ports*>* obj = new std::vector<ports*>();
    objects_.push_back(obj);
    return obj;
  }
  private:
  static std::vector<std::vector<ports*>*> objects_;
  };

};

#endif

